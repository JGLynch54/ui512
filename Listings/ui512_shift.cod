Microsoft (R) Macro Assembler (x64) Version 14.50.35721.0   12/24/25 13:55:07
ui512_shift.asm						     Page 1 - 1


				;
				;			ui512_shift
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;
				;			File:			ui512_shift.asm
				;			Author:			John G. Lynch
				;			Legal:			Copyright @2025, per MIT License below
				;			Date:			November 19, 2025  (file creation)

								INCLUDE			ui512_legalnotes.inc
			      C ;
			      C ;			ui512 Legal Notes
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			File:			ui512_legalnotes.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright 2025, per MIT License included
			      C ;			Date:			Octoberr 24, 2025
			      C ;
			      C IFNDEF							ui512_legalnotes_INC
 = 00000001		      C ui512_legalnotes_INC			EQU		1
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			Notes:
			      C ;				ui512 is a small project to provide basic operations for a variable type of unsigned 512 bit integer.
			      C ;
			      C ;				ui512a provides basic operations: zero, copy, compare, add, subtract.
			      C ;				ui512b provides basic bit-oriented operations: shift left, shift right, and, or, not, least significant bit and most significant bit.
			      C ;               ui512md provides multiply and divide.
			      C ;
			      C ;				It is written in assembly language, using the MASM (ml64) assembler provided as an option within Visual Studio.
			      C ;				(currently using VS Community 2022 17.14.10)
			      C ;
			      C ;				It provides external signatures that allow linkage to C and C++ programs,
			      C ;				where a shell/wrapper could encapsulate the methods as part of an object.
			      C ;
			      C ;				Note: X64 ZMM regs are "little-endian". The 8 QWORD C array declarion is "big-endian".
			      C ;				In memory the most significant word is first: var[0], the least last var[7]. Normally not an issue,
			      C ;				but when that var is laoded in a Z-reg, the least significant is first, and the most last, which is
			      C ;				the way z-regs are loaded, but convention has the z-reg first word commonly termed the most significant, 
			      C ;				which is not the way our c arrays are defined. Not an issue programmatically, but often a qword shift left, or right
			      C ;				or a carry or borrow to the next most significant word is not the same when the data is in a z-reg.
			      C ;
			      C ;				It has assembly time options directing the use of Intel processor extensions: AVX4, AVX2, SIMD, or none:
			      C ;				(Z (512), Y (256), or X (128) registers, or regular Q (64bit)).
			      C ;
			      C ;				Note: The file "compile_time_options.inc" contains the options that can be configured for extension usage, and other options.
			      C ;
			      C ;				If processor extensions are used, the caller must align the variables declared and passed
			      C ;				on the appropriate byte boundary (e.g. alignas 64 for 512)
			      C ;
			      C ;				The modules (in total) are very light-weight (less than 10K bytes) and relatively fast,
			      C ;				but is not intended for all processor types or all environments. 
			      C ;
			      C ;				Intended use cases:
			      C ;					1.) a "sum of primes" for primes up to 2^48. 
			      C ;					2.) elliptical curve cryptography (ECC)
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			MIT License
			      C ;
			      C ;			Copyright (c) 2024 John G. Lynch
			      C ;
			      C ;				Permission is hereby granted, free of charge, to any person obtaining a copy
			      C ;				of this software and associated documentation files (the "Software"), to deal
			      C ;				in the Software without restriction, including without limitation the rights
			      C ;				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			      C ;				copies of the Software, and to permit persons to whom the Software is
			      C ;				furnished to do so, subject to the following conditions:
			      C ;
			      C ;				The above copyright notice and this permission notice shall be included in all
			      C ;				copies or substantial portions of the Software.
			      C ;
			      C ;				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			      C ;				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			      C ;				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			      C ;				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			      C ;				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			      C ;				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			      C ;				SOFTWARE.
			      C ;
			      C ENDIF			; ui512_legalnotes_INC
			      C 
								INCLUDE			ui512_compile_time_options.inc
			      C ;
			      C ;			ui512_compile_time_options
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			File:			ui512_compile_time_options.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2025, per MIT License included
			      C ;			Date:			August 20, 2025 (file creation)
			      C ;
			      C IFNDEF							compile_time_options_INC
 = 1			      C compile_time_options_INC		EQU			<1>
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Configuration choices
			      C ;
			      C ;	Note: Choosing these options requires knowledge of the target machine CPU model. If you are unsure of the capabiites of the target machine CPU,
			      C ;	You can use the "CPU-Z" tool. https://www.cpuid.com/downloads/cpu-z/cpu-z_2.09-en.exe 
			      C ;	Basically, Intel Skylake and later can use "Z", Haswell and later can use BMI2, etc. 
			      C ;	Too many processors, options, vendors for me to list here. Go to the CPU vendor specifications, or use the tool to inform your choice.
			      C ;
			      C ;	Note: This is intended to be a mutually exclusive choice (UseZ thru UseQ).
			      C ;	However, the coding of the options selects the "highest" one used and ignores the rest ( If __UseZ ... ELSEIF __UseY ... )
			      C 
 = 00000001		      C __UseZ			EQU				1									; Use AVX4 processor features (512 bit registers and instructions)
 = 00000000		      C __UseY			EQU				0									; Use AVX2 processor features (256 bit registers and instructions)
 = 00000000		      C __UseX			EQU				0									; Use SIMD/SSE processor features (128 bit registers and instructions)
 = 00000001		      C __UseQ			EQU				1									; Do not use extensions, use standard x64 bit registers and instructions
			      C ;
 = 00000001		      C __UseBMI2		EQU				1									; Bit manipulation instructions (Haswell and later) ref:https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set
			      C ;
 = 00000001		      C __VerifyRegs	EQU				1									; in debug mode, or with unit tests, define routine to verify non-volatile regs 
 = 00000000		      C __CheckAlign	EQU				0									; User is expected to pass arguments aligned on 64 byte boundaries, 
			      C ;																	; This setting enforces that with a check. It should not be necessary, but included to help debugging
			      C 
			      C ENDIF			; ui512_compile_time_options_INC
			      C 
								INCLUDE			ui512_macros.inc
			      C ;
			      C ;			ui512 Macros
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			File:			ui512_macros.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2025, per MIT License included
			      C ;			Date:			October 24, 2025  (file creation)
			      C ;
			      C IFNDEF							ui512_macros_INC
 = 1			      C ui512_macros_INC				EQU		<1>
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ; Some coding shortcuts
			      C ;
 = ZMMWORD PTR		      C ZM_PTR			EQU				ZMMWORD PTR 
 = YMMWORD PTR		      C YM_PTR			EQU				YMMWORD PTR
 = XMMWORD PTR		      C XM_PTR			EQU				XMMWORD PTR
 = QWORD PTR		      C Q_PTR			EQU				QWORD PTR
 = DWORD PTR		      C D_PTR			EQU				DWORD PTR
 = WORD PTR		      C W_PTR			EQU				WORD PTR
 = BYTE PTR		      C B_PTR			EQU				BYTE PTR
 = DWORD BCST		      C m32BCST			EQU				DWORD BCST
 = QWORD BCST		      C m64BCST			EQU				QWORD BCST
			      C LPVOID			TYPEDEF			PTR VOID
			      C 
			      C ; Mask codes (for compares using instructions like VPCMPUQ)
 = 00000000		      C CPEQ			EQU				0
 = 00000001		      C CPLT			EQU				1
 = 00000002		      C CPLE			EQU				2
 = 00000003		      C CPFALSE			EQU				3
 = 00000004		      C CPNE			EQU				4
 = 00000005		      C CPGE			EQU				5
 = 00000006		      C CPGT			EQU				6
 = 00000007		      C CPTRUE			EQU				7
			      C 
			      C ; Masks commonly used: here in Record form, which can be used as immediate values. Example: OR	R8D, MASK kMask.b8
			      C kMask			RECORD			b8:1, b7:1, b6:1, b5:1, b4:1, b3:1, b2:1, b1:1, b0:1
			      C 
			      C ; Return codes commonly used.	
 = 00000000		      C retcode_zero	EQU				0
 = 00000001		      C retcode_one		EQU				1
 =-00000001		      C retcode_neg_one	EQU				-1
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;           Notes on x64 calling conventions        specifically "fast call"
			      C ; ref: https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170
			      C ; The callers first four parameters are passed in registers: RCX, RDX, R8, R9 if integer or address; if floating point XMM0L, XMM1L, XMM2L, XMM3L
			      C ; return (if any) is in EAX
			      C ;
			      C ; RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile, and do not need to be saved
			      C ; XMM0, YMM0, ZMM0 and  ..1, ..2, ..3, ..4, and ..5 are considered volatile, and do not need to be saved
			      C ; ZMM16 to ZMM31: volatile, also do not need to be zeroed to resume full clock speeds
			      C ;
			      C ; R12, R13, R14, R15, RDI, RSI, RBX, RBP, RSP are non-volatile and if used, must be restored
			      C ; XMM, YMM, and ZMM ..6 thru 15 are non-volatile and if used, must be restored
			      C ;
			      C ; A "leaf" function is one that does not call and does not change non volatile registers
			      C ; leaf functionss therefore do not need frame, prolog or epilog
			      C ;
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; Selected macros from "macamd64.inc" (c) Microsoft Corporation
			      C ;	These macros generate .xdata and .pdata entries in the executable image file.
			      C ;	The entries assist in exception and debugging; helping 'unwind' operations.
			      C ;	Only a few macros are included, and are reformatted to match coding style:;	indents and capitalization.
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; Leaf_Entry <Name>
			      C ;
			      C ; Macro Description:
			      C ;   This macro indicates the beginning of a leaf function.;
			      C ;
			      C ; Arguments:
			      C ;   Name - Supplies the name of the function
			      C ;   
			      C Leaf_Entry		MACRO			Name
			      C 				DB				6 DUP (0cch)
			      C 				ALIGN			16
			      C 				PUBLIC			Name
			      C Name			PROC
			      C ; Addresses of param regs "home" after reg pushs, and _allocspace adjust
			      C RCXHome			EQU				Q_PTR [ RSP + ( 1 * 8 ) ]	
			      C RDXHome			EQU				Q_PTR [ RSP + ( 2 * 8 ) ]
			      C R8Home			EQU				Q_PTR [ RSP + ( 3 * 8 ) ]
			      C R9Home			EQU				Q_PTR [ RSP + ( 4 * 8 ) ]
			      C 				ENDM
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; Proc_w_Local	ProcName, LocalStructName, NV_Regs_Used:vararg
			      C ;
			      C Proc_w_Local	MACRO			ProcName, LocalStructName, NV_Regs_Used:vararg
			      C 
			      C _shadowspace	EQU				40h								; stack space for caller (at top) and callee (at bottom)
			      C _localspace		=				sizeof (LocalStructName)		; space needed (on stack) for local variables
			      C _alignspace		EQU				64								; amount of space that might get truncated to get frame space aligned on specified boundary (64)
			      C _allocspace		=				_localspace + ( 2 * _shadowspace) + _alignspace	; calculate total stack space to allocate.
			      C 
			      C 				DB				6 DUP (0cch)
			      C 				ALIGN			16
			      C 				PUBLIC			ProcName						; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
			      C ProcName		PROC			FRAME
			      C 				
			      C 				MOV				[ RSP + ( 1 * 8) ], RCX
			      C 				push_reg        RBP								; standard prologue code
			      C 
			      C 	nRegs = 1
			      C 				FOR				reg, <NV_Regs_Used>				; save specified non-volatile regs on stack (in top shadowspace)
			      C 				push_reg		reg
			      C 	nRegs = nRegs + 1
			      C 				ENDM
			      C 
			      C 				SUB				RSP, _allocspace				; set stack pointer down by space needed (locals+ (2 * shadowspace))
			      C 				.ALLOCSTACK		_allocspace
			      C 	
			      C ; set frame pointer within new space, but above shadowspace
			      C 				LEA				RBP, ( _shadowspace + _alignspace ) [ RSP ]
			      C 				AND				RBP, -_alignspace				; truncate low bits of base pointer to yield aligned pointer
			      C 
			      C 				.ENDPROLOG
			      C ; Addresses of param regs "home" after reg pushs, and _allocspace adjust
			      C RCXHome			EQU				Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 1 ) * 8 ) ) ]
			      C RDXHome			EQU				Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 2 ) * 8 ) ) ] 
			      C R8Home			EQU				Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 3 ) * 8 ) ) ]
			      C R9Home			EQU				Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 4 ) * 8 ) ) ]
			      C l_Ptr			EQU				[RBP] + LocalStructName			; set up shortcut for accessing local data structure
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; Local_Exit	NV_Regs_Used:vararg
			      C ;
			      C Local_Exit		MACRO			NV_Regs_Used:vararg
			      C 				ADD				RSP,  _allocspace
			      C 				FOR				reg, <NV_Regs_Used>
			      C 				POP				reg
			      C 				ENDM 
			      C 				POP				RBP
			      C 				RET
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; push_reg	reg (non-volatile) to push
			      C ;
			      C push_reg		MACRO			reg
			      C 				PUSH			reg
			      C 				.PUSHREG		reg
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; CheckAlign <RAddr>
			      C ;
			      C ;			Test passed variable addresses for 64 byte alignment
			      C ;			Note: Better performance if this is off, but for debugging, maybe have it on
			      C ;
			      C CheckAlign		MACRO			Raddr:REQ, ExitLbl:VARARG
			      C 	IF	__CheckAlign
			      C 				TEST			Raddr, 63							; Is specified param aligned 64?
			      C 				JZ				@F									; Yes, passes test, continue
			      C 				MOV				EAX, 0C0000005h						; Windows code for General Protection Fault	
			      C 		IFNB	<ExitLbl>
			      C 				JMP				ExitLbl								; Return to caller, with GPFault code in EAX
			      C 		ELSE
			      C 				RET													; No, fault return with err code
			      C 		ENDIF
			      C @@:
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Zero a 512 bit destination, conditional assembly based on configuration parameters
			      C ;
			      C Zero512			MACRO			dest:REQ
			      C 	IF		__UseZ
			      C 				CheckAlign		dest
			      C 				VPXORQ			ZMM31, ZMM31, ZMM31
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				VPXORQ			YMM4, YMM4, YMM4
			      C 				FOR				idx, < 0, 4 >
			      C 				VMOVDQA64		YM_PTR [ dest ] [ idx * 8 ], YMM4
			      C 				ENDM
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				PXOR			XMM4, XMM4
			      C 				FOR				idx, < 0, 2, 4, 6 >
			      C 				MOVDQA			XM_PTR [ dest ] [ idx * 8 ], XMM4
			      C 				ENDM		
			      C 	ELSE
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Zero a 512 bit destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Zero512Q		MACRO			dest:REQ
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Copy a 512 bit source to destination, conditional assembly based on configuration parameters
			      C ;
			      C Copy512			MACRO			dest:REQ, src:REQ
			      C 	IF		__UseZ 
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		ZMM31, ZM_PTR [ src ]
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		YMM4, YM_PTR [ src + 0 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			      C 				VMOVDQA64		YMM5, YM_PTR [ src ] [ 4 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 4 * 8 ], YMM5
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 0 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 0 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 2 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 2 * 8 ], XMM3
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 4 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 4 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 6 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 6 * 8 ], XMM3
			      C 	ELSE
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Copy a 512 bit source to destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Copy512Q		MACRO			dest:REQ, src:REQ
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;	VerifyRegs <none>
			      C ;
			      C ;			If option is on, generate a function, callable by unit test routines, 
			      C ;				to save non-volatile registers in passed structure.
			      C ;
			      C IF	__VerifyRegs
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* regstruct)
			      C ;			reg_verify		-	copy non-volatile regs into callers struct of nine qwords) intended for unit tests to verify non-volatile regs are not changed
			      C ;			Prototype:		-	void reg_verify( uu64* regstruct);
			      C ;			regstruct		-	Address of 9 QWORDS in a struct where regs will be copied (in RCX)
			      C ; //			reg_verify		-	save non-volatile regs for verification (debug)
			      C ; //			Prototype		-	void reg_verify ( u64* reg struct)
			      C 
			      C EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* reg struct)
			      C 
			      C VerifyRegs		MACRO
			      C 				Leaf_Entry		reg_verify
			      C 				MOV				Q_PTR [ RCX ] [ 0 * 8 ], R12
			      C 				MOV				Q_PTR [ RCX ] [ 1 * 8 ], R13
			      C 				MOV				Q_PTR [ RCX ] [ 2 * 8 ], R14
			      C 				MOV				Q_PTR [ RCX ] [ 3 * 8 ], R15
			      C 				MOV				Q_PTR [ RCX ] [ 4 * 8 ], RDI
			      C 				MOV				Q_PTR [ RCX ] [ 5 * 8 ], RSI
			      C 				MOV				Q_PTR [ RCX ] [ 6 * 8 ], RBX
			      C 				MOV				Q_PTR [ RCX ] [ 7 * 8 ], RBP
			      C 				MOV				Q_PTR [ RCX ] [ 8 * 8 ], RSP
			      C 				RET
			      C reg_verify		ENDP
			      C 				ENDM
			      C ENDIF
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Get a GP reg QWORD from within a Z register as specified by mask
			      C ;			Note: RAX, ZMM0 and k1 are used and not restored
			      C ;			Example usage: GetZatIdx R11, ZMM1, MaskBit2 or SetZatIdx ZMM1, R12, [ R9 ]  (where R9 is a bit mask, not an integer index)
			      C ;			Note: These are req to reg ops; no memory fetches (other than instructions from pipeline)
			      C ;
			      C GetZatMask		MACRO			dest, src, mask
			      C 				LEA				RAX,  mask
			      C 				KMOVB			k1, RAX
			      C 				VPCOMPRESSQ		ZMM0 {k1}{z}, src
			      C 				VMOVQ			dest, XMM0
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Set a GP Reg QWORD within a Z register as specified by mask
			      C ;			Note: RAX and k1 are used and not restored
			      C ;			Example usage: SetZatIdx ZMM1, R8, MaskBit2
			      C ;			Note: These are req to reg ops; no memory fetches (other than instructions from pipeline)
			      C ;
			      C SetZatMask		MACRO			dest, src, mask
			      C 				LEA				RAX, mask
			      C 				KMOVB			k1, RAX
			      C 				VPBROADCASTQ 	dest {k1}, src
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ENDIF			; ui512_macros_INC
			      C 
								INCLUDE			ui512_externs.inc
			      C ;
			      C ;			ui512 Externs
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			File:			ui512_externs.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2025, per MIT License included
			      C ;			Date:			October 24, 2025
			      C ;
			      C IFNDEF							ui512_externs_INC
 = 1			      C ui512_externs_INC				EQU		<1>
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;   header file equivalent extern declarations
			      C ;			EXTERN "C" signatures 
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_clear_copy_set.asm:
			      C ;
			      C ;	// void zero_u ( u64* destarr ); 
			      C ;	// fill supplied 512bit (8 QWORDS) with zero
			      C EXTERNDEF		zero_u:PROC
			      C 
			      C ;	// void copy_u ( u64* destarr, u64* srcarr );
			      C ;	// copy supplied 512bit (8 QWORDS) source to supplied destination
			      C EXTERNDEF		copy_u:PROC
			      C 
			      C ;	// void set_uT64 ( u64* destarr, u64 value );
			      C ;	// set supplied destination 512 bit to supplied u64 value
			      C EXTERNDEF		set_uT64:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_compare.asm
			      C ;
			      C ;	// s16 compare_u ( u64* lh_op, u64* rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied RH operand
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_u:PROC
			      C 
			      C ;	// s16 compare_uT64 ( u64* lh_op, u64 rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied 64bit RH operand (value)
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_uT64:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_addition.asm
			      C ;
			      C ;	// s16 add_u ( u64* sum, u64* addend1, u64* addend2 );
			      C ;	// add supplied 512bit (8 QWORDS) sources, place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_u:PROC
			      C 
			      C ;	// s16 add_u_wc ( u64* sum, u64* addend1, u64* addend2, s16 carry );
			      C ;	// add supplied 512bit (8 QWORDS) sources, with passed-in carry, place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_u_wc:PROC
			      C 
			      C ;	// s16 add_uT64 ( u64* sum, u64* addend1, u64 addend2 );
			      C ;	// add 64bit QWORD (value) to supplied 512bit (8 QWORDS), place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_uT64:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_subtraction.asm
			      C ;
			      C ;	// s16 sub_u ( u64* difference, u64* left operand, u64* right operand );
			      C ;	// subtract supplied 512bit (8 QWORDS) RH OP from LH OP giving difference in destination
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_u:PROC
			      C 
			      C ;	// s16 sub_u_wc ( u64* difference, u64* left operand, u64* right operand, s16 borrow );
			      C ;	// subtract supplied 512bit (8 QWORDS) RH OP from LH OP, with passed-in borrow giving difference in destination
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_u_wb:PROC
			      C 
			      C ;	// s16 sub_uT64( u64* difference, u64* left operand, u64 right operand );
			      C ;	// subtract supplied 64 bit right hand (64 bit value) op from left hand (512 bit) giving difference
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_uT64:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_multiply.asm
			      C ;
			      C ; //			mult_uT64		-	multiply 512 bit multiplicand by 64 bit multiplier, giving 512 product, 64 bit overflow
			      C ; //			Prototype:		-	s16 mult_uT64( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
			      C EXTERNDEF		mult_uT64:PROC	;	s16 mult_uT64( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
			      C 
			      C ; //			mult_u			-	multiply 512 multiplicand by 512 multiplier, giving 512 product, overflow
			      C ; //			Prototype:		-	s16 mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier);
			      C EXTERNDEF		mult_u:PROC		;	s16 mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier);
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_division.asm
			      C ;
			      C ; //			div_uT64		-	divide 512 bit dividend by 64 bit bit divisor, giving 512 bit quotient and 64 bit remainder
			      C ; //			Prototype:		-	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64 divisor,);
			      C EXTERNDEF		div_uT64:PROC	;	s16 div_uT64( u64* quotient, u64* remainder, u64* dividend, u64 divisor);
			      C 
			      C ; //			div_u			-	divide 512 bit dividend by 512 bit divisor, giving 512 bit quotient and remainder
			      C ; //			Prototype:		-	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor);
			      C EXTERNDEF		div_u:PROC		;	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor);
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_significance.asm
			      C 
			      C ;   // find most significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 msb_u( u64* );
			      C ;   // returns: -1 if no most significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C ;	//	Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit).
			      C ;	//			a returned 511 means bit63 of the first word; (the left most bit).	
			      C EXTERNDEF		msb_u:PROC
			      C 
			      C ;   // find least significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 lsb_u( u64* );
			      C ;   // returns: -1 if no least significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C ;	//	Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit).
			      C ;	//			a returned 511 means bit63 of the first word; (the left most bit).	
			      C EXTERNDEF		lsb_u:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_shift.asm
			      C ;
			      C ;   // void shr_u ( u64* destination, u64* source, u16 bits_to_shift )
			      C ;   // shift supplied source 512bit (8 QWORDS) right, put in destination
			      C EXTERNDEF		shr_u:PROC
			      C 
			      C ;   // void shl_u ( u64* destination, u64* source, u16 bits_to_shift );
			      C ;   // shift supplied source 512bit (8 QWORDS) left, put in destination
			      C EXTERNDEF		shl_u:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_bitops
			      C ;
			      C ;   // void and_u ( u64* destination, u64* lh_op, u64* rh_op );
			      C ;   // logical 'AND' bits in lh_op, rh_op, put result in destination
			      C EXTERNDEF		and_u:PROC
			      C 
			      C ;   // logical 'OR' bits in lh_op, rh_op, put result in destination
			      C ;   // void or_u( u64* destination, u64* lh_op, u64* rh_op);
			      C EXTERNDEF		or_u:PROC
			      C 
			      C ;   // logical 'XOR' bits in lh_op, rh_op, put result in destination
			      C ;   // void xor_u( u64* destination, u64* lh_op, u64* rh_op);
			      C EXTERNDEF		xor_u:PROC
			      C 
			      C ;   // logical 'NOT' bits in source, put result in destination
			      C ;	// void not_u( u64* destination, u64* source);
			      C EXTERNDEF		not_u:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_global_data
			      C ;
			      C EXTERNDEF		qOnes:QWORD
			      C EXTERNDEF		qZero:QWORD
			      C 
			      C EXTERNDEF		ret_zero:DWORD
			      C EXTERNDEF		ret_one:DWORD
			      C EXTERNDEF		ret_neg_one:DWORD
			      C EXTERNDEF		ret_GPFault:DWORD
			      C 
			      C EXTERNDEF		mskB0:DB
			      C EXTERNDEF		mskB1:DB
			      C EXTERNDEF		mskB2:DB
			      C EXTERNDEF		mskB3:DB
			      C EXTERNDEF		mskB4:DB
			      C EXTERNDEF		mskB5:DB
			      C EXTERNDEF		mskB6:DB
			      C EXTERNDEF		mskB7:DB
			      C EXTERNDEF		mskAll8:DB
			      C 
			      C ENDIF			; ui512_externs_INC
			      C 
			      C 
				.NOLISTIF
								OPTION			CASEMAP:NONE
 00000000			ui512_shift		SEGMENT			PARA 'CODE'

					IF __UseZ		; Only need these tables if using zmm regs

				; Note: storage of qwords in ZMM regs is in 'reverse' order, with the lowest index holding the most significant qword
				;			so index 0 holds bits 511-448, index 7 holds bits 63-0
				; But when the ZMM reg is stored to memory, the order is 'normal', with the lowest address holding the most significant qword

				; table of indices for permuting words in a zmm reg to achieve right shifts by words
							;	PUBLIC			ShiftPermuteRt
								ALIGN			16
 00000000			ShiftPermuteRt	QWORD			0, 1, 2, 3, 4, 5, 6, 7			; identity permute for shift left/right by words
	   0000000000000000
	   0000000000000001
	   0000000000000002
	   0000000000000003
	   0000000000000004
	   0000000000000005
	   0000000000000006
	   0000000000000007
 00000040  0000000000000000					QWORD			0, 0, 1, 2, 3, 4, 5, 6			; shift right by one word
	   0000000000000000
	   0000000000000001
	   0000000000000002
	   0000000000000003
	   0000000000000004
	   0000000000000005
	   0000000000000006
 00000080  0000000000000000					QWORD			0, 0, 0, 1, 2, 3, 4, 5			; shift right by two words
	   0000000000000000
	   0000000000000000
	   0000000000000001
	   0000000000000002
	   0000000000000003
	   0000000000000004
	   0000000000000005
 000000C0  0000000000000000					QWORD			0, 0, 0, 0, 1, 2, 3, 4			; shift right by three words
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000001
	   0000000000000002
	   0000000000000003
	   0000000000000004
 00000100  0000000000000000					QWORD			0, 0, 0, 0, 0, 1, 2, 3			; shift right by four words
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000001
	   0000000000000002
	   0000000000000003
 00000140  0000000000000000					QWORD			0, 0, 0, 0, 0, 0, 1, 2			; shift right by five words
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000001
	   0000000000000002
 00000180  0000000000000000					QWORD			0, 0, 0, 0, 0, 0, 0, 1			; shift right by six words
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000001
 000001C0  0000000000000000					QWORD			0, 0, 0, 0, 0, 0, 0, 0			; shift right by seven words
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000

				; table of indices for permuting words in a zmm reg to achieve left shifts by words
							;	PUBLIC			ShiftPermuteLt
 00000200			ShiftPermuteLt	QWORD			0, 1, 2, 3, 4, 5, 6, 7			; identity permute for shift left/right by words
	   0000000000000000
	   0000000000000001
	   0000000000000002
	   0000000000000003
	   0000000000000004
	   0000000000000005
	   0000000000000006
	   0000000000000007
 00000240  0000000000000001					QWORD			1, 2, 3, 4, 5, 6, 7, 0			; shift left by one word
	   0000000000000002
	   0000000000000003
	   0000000000000004
	   0000000000000005
	   0000000000000006
	   0000000000000007
	   0000000000000000
 00000280  0000000000000002					QWORD			2, 3, 4, 5, 6, 7, 0, 0			; shift left by two words
	   0000000000000003
	   0000000000000004
	   0000000000000005
	   0000000000000006
	   0000000000000007
	   0000000000000000
	   0000000000000000
 000002C0  0000000000000003					QWORD			3, 4, 5, 6, 7, 0, 0, 0			; shift left by three words
	   0000000000000004
	   0000000000000005
	   0000000000000006
	   0000000000000007
	   0000000000000000
	   0000000000000000
	   0000000000000000
 00000300  0000000000000004					QWORD			4, 5, 6, 7, 0, 0, 0, 0			; shift left by four words
	   0000000000000005
	   0000000000000006
	   0000000000000007
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
 00000340  0000000000000005					QWORD			5, 6, 7, 0, 0, 0, 0, 0			; shift left by five words
	   0000000000000006
	   0000000000000007
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
 00000380  0000000000000006					QWORD			6, 7, 0, 0, 0, 0, 0, 0			; shift left by six words
	   0000000000000007
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
 000003C0  0000000000000007					QWORD			7, 0, 0, 0, 0, 0, 0, 0			; shift left by seven words	
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000
	   0000000000000000

					
				; When shifting, some words become zero,table of masks for zeroing words when shifting right
							;	PUBLIC			ShiftMaskRt
 00000400 FF FE FC F8 F0	ShiftMaskRt		DB				0ffh, 0feh, 0fch, 0f8h, 0f0h, 0e0h, 0c0h, 080h
	   E0 C0 80

				; When shifting, some words become zero,table of masks for zeroing words when shifting left
							;	PUBLIC			ShiftMaskLt
 00000408 FF 7F 3F 1F 0F	ShiftMaskLt		DB				0ffh, 07fh, 03fh, 01fh, 0fh, 07h, 03h, 01h	
	   07 03 01


					ENDIF		; __UseZ

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;	ShiftOrR	MACRO
				;			Each word is shifted right, and the bits shifted out are ORd into the next (less significant) word.
				;			RCX holds the number of bits to shift right, RBX holds the 64 bit complement for left shift.
				;
				ShiftOrR		MACRO			lReg, rReg
								SHLX			RDX, lReg, RBX					; shift 'bottom' bits to top
								SHRX			rReg, rReg, RCX					; shift target bits right (leaving zero filled bits at top)
								OR				rReg, RDX						; OR in new 'top' bits
								ENDM

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;	ShiftOrL	MACRO
				;			Each word is shifted left, and the bits shifted out are ORd into the next (more significant) word.
				;			RCX holds the number of bits to shift left, RBX holds the 64 bit complement for right shift.
				;
				ShiftOrL		MACRO			lReg, rReg
								SHRX			RDX, lReg, RBX					; shift 'top' bits to bottom
								SHLX			rReg, rReg, RCX					; shift target bits left (leaving zero filled bits at bottom)
								OR				rReg, RDX						; OR in new 'bottom' bits
								ENDM


				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			shr_u		-	shift supplied source 512bit (8 QWORDS) right, put in destination
				;			Prototype:		void shr_u( u64* destination, u64* source, u32 bits_to_shift)
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			source		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			bits		-	Number of bits to shift. Will fill with zeros, truncate those shifted out (in R8W)
				;			returns		-	nothing (0)
				;			Note: unwound loop(s). More instructions, but fewer executed (no loop save, setup, compare loop), faster, fewer regs used

				IF	__UseZ
								Leaf_Entry		shr_u				; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
 00000410  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000420		     1	shr_u			PROC
								CheckAlign		RCX								; (OUT) destination of shifted 8 QWORDs
								CheckAlign		RDX								; (IN)	source of 8 QWORDS

 00000420  66| 41/ 81 F8					CMP				R8W, 512						; handle edge case, shift 512 or more bits
	   0200
 00000426  7C 0D						JL				@F
								Zero512			RCX								; zero destination, return
 00000428  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 0000042E  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 00000434  C3							RET

 00000435  49/ 81 E0		@@:				AND				R8, 511							; ensure no high bits above shift count
	   000001FF
 0000043C  75 12						JNZ				@@shift							; handle edge case, zero bits to shift
 0000043E  48/ 3B CA						CMP				RCX, RDX
 00000441  74 0C						JE				@F								; destination is the same as the source: no copy needed
								Copy512			RCX, RDX						; no shift, just copy (destination, source already in regs), return
 00000443  62 61 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 00000449  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 0000044F  C3			@@:				RET

 00000450  62 61 FD 48/ 6F	@@shift:		VMOVDQA64		ZMM31, ZM_PTR [ RDX ]			; load the 8 qwords into zmm reg (note: word order)
	   3A
 00000456  49/ 8D 00						LEA				RAX, [ R8 ]
 00000459  66| 83 E0 3F						AND				AX, 03fh						; limit shift count to 63 (shifting bits only here, not words)
 0000045D  74 19						JZ				@F								; if true, must be multiple of 64 bits to shift, no bits, just words to shift
 0000045F  62 62 FD 48/ 7C					VPBROADCASTQ	ZMM29, RAX						; Nr bits to shift right
	   E8
 00000465  62 01 9D 40/ EF					VPXORQ			ZMM28, ZMM28, ZMM28				; 
	   E4
 0000046B  62 03 85 40/ 03					VALIGNQ			ZMM30, ZMM31, ZMM28, 7			; shift copy of words left one word (to get low order bits aligned for shift)
	   F4 07
 00000472  62 02 8D 40/ 73					VPSHRDVQ		ZMM31, ZMM30, ZMM29				; shift, concatenating low bits of next word with each word to shift in
	   FD

				; with the bits shifted within the words (if needed), if the desired shift is more than 64 bits, word shifts are required
 00000478  48/ 8D 05		@@:				LEA				RAX, ShiftMaskRt	
	   00000400 R
 0000047F  66| 41/ C1 E8					SHR				R8W, 6							; divide Nr bits to shift by 64 giving Nr words to shift (can only be 0-7 based on above validation)
	   06
 00000484  4A/ 8D 04 00						LEA				RAX,  [ RAX ] [ R8 ]			; Add index to base address of mask table
 00000488  C5 F9/ 90 08						KMOVB			K1, B_PTR [ RAX ]				; load mask for words to be zeroed
 0000048C  48/ 8D 05						LEA				RAX, ShiftPermuteRt				; address of permute table
	   00000000 R
 00000493  66| 41/ C1 E0					SHL				R8W, 6							; multiply by 64 to get offset into permute table		
	   06
 00000498  62 41 FD 48/ 6F					VMOVDQA64		ZMM29, ZM_PTR [R8] [ RAX ]		; load permute indices (with calculated offset)
	   2C 00
 0000049F  62 02 95 C1/ 36					VPERMQ			ZMM31 {k1}{z}, ZMM29, ZMM31		; permute words in zmm31 to achieve word shift
	   FF
 000004A5  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR [ RCX ], ZMM31			; store result at callers destination
	   39
 000004AB  C3							RET
 000004AC			shr_u			ENDP

					ELSE
				ENDIF
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			shl_u		-	shift supplied source 512bit (8 QWORDS) left, put in destination
				;			Prototype:		void shl_u( u64* destination, u64* source, u16 bits_to_shift);
				;			destination	-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RCX)
				;			source		-	Address of 64 byte aligned array of 8 64-bit words (QWORDS) 512 bits (in RDX)
				;			bits		-	Number of bits to shift. Will fill with zeros, truncate those shifted out (in R8W)
				;			returns		-	nothing (0)

				IF	__UseZ
								Leaf_Entry		shl_u				; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
 000004AC  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 000004C0		     1	shl_u			PROC
								CheckAlign		RCX								; (OUT) destination of shifted 8 QWORDs
								CheckAlign		RDX								; (IN)	source of 8 QWORDS

 000004C0  66| 41/ 81 F8					CMP				R8W, 512						; handle edge case, shift 512 or more bits
	   0200
 000004C6  7C 0D						JL				@F
								Zero512			RCX								; zero destination
 000004C8  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000004CE  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 000004D4  C3							RET
 000004D5  49/ 81 E0		@@:				AND				R8, 511							; mask out high bits above shift count, test for 0
	   000001FF
 000004DC  75 12						JNE				@F								; handle edge case, shift zero bits
 000004DE  48/ 3B CA						CMP				RCX, RDX						; destination same as source?
 000004E1  74 0C						JE				@@r								; no copy needed
								Copy512			RCX, RDX						; no shift, just copy (destination, source already in regs)
 000004E3  62 61 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 000004E9  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 000004EF  C3			@@r:			RET
 000004F0  62 61 FD 48/ 6F	@@:				VMOVDQA64		ZMM31, ZM_PTR [ RDX ]			; load the 8 qwords into zmm reg (note: word order)
	   3A
 000004F6  49/ 8D 00						LEA				RAX, [ R8 ]
 000004F9  66| 83 E0 3F						AND				AX, 03fh
 000004FD  74 19						JZ				@F								; must be multiple of 64 bits to shift, no bits, just words to shift

				; Do the shift of bits within the 64 bit words
 000004FF  62 62 FD 48/ 7C					VPBROADCASTQ	ZMM29, RAX						; Nr bits to shift left
	   E8
 00000505  62 01 9D 40/ EF					VPXORQ			ZMM28, ZMM28, ZMM28				; 
	   E4
 0000050B  62 03 9D 40/ 03					VALIGNQ			ZMM30, ZMM28, ZMM31, 1			; shift copy of words right one word (to get low order bits aligned for shift)
	   F7 01
 00000512  62 02 8D 40/ 71					VPSHLDVQ		ZMM31, ZMM30, ZMM29				; shift, concatenating low bits of next word with each word to shift in
	   FD

				; with the bits shifted within the words, if the desired shift is more than 64 bits, word shifts are required
 00000518  48/ 8D 05		@@:				LEA				RAX, ShiftMaskLt	
	   00000408 R
 0000051F  66| 41/ C1 E8					SHR				R8W, 6							; divide Nr bits to shift by 64 giving Nr words to shift (can only be 0-7 based on above validation)
	   06
 00000524  4A/ 8D 04 00						LEA				RAX, [ RAX ] [ R8 ]				; Add index to base address of mask table
 00000528  C5 F9/ 90 08						KMOVB			K1, B_PTR [ RAX ]				; create mask for words to be zeroed
 0000052C  48/ 8D 05						LEA				RAX, ShiftPermuteLt				; address of permute table
	   00000200 R
 00000533  66| 41/ C1 E0					SHL				R8W, 6							; multiply by 64 to get offset into permute table		
	   06
 00000538  62 41 FD 48/ 6F					VMOVDQA64		ZMM29, ZM_PTR [ R8 ] [ RAX ]	; load permute indices (with calculated offset)
	   2C 00
 0000053F  62 02 95 C1/ 36					VPERMQ			ZMM31 {k1}{z}, ZMM29, ZMM31		; permute words in zmm31 to achieve word shift
	   FF
 00000545  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR [ RCX ], ZMM31			; store result at callers destination
	   39
 0000054B  C3							RET
 0000054C			shl_u			ENDP			
					ELSE
					ENDIF

 0000054C			ui512_shift		ENDS												; end of section
								END													; end of module
Microsoft (R) Macro Assembler (x64) Version 14.50.35721.0   12/24/25 13:55:07
ui512_shift.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

CheckAlign . . . . . . . . . . .	Proc
Copy512Q . . . . . . . . . . . .	Proc
Copy512  . . . . . . . . . . . .	Proc
GetZatMask . . . . . . . . . . .	Proc
Leaf_Entry . . . . . . . . . . .	Proc
Local_Exit . . . . . . . . . . .	Proc
Proc_w_Local . . . . . . . . . .	Proc
SetZatMask . . . . . . . . . . .	Proc
ShiftOrL . . . . . . . . . . . .	Proc
ShiftOrR . . . . . . . . . . . .	Proc
VerifyRegs . . . . . . . . . . .	Proc
Zero512Q . . . . . . . . . . . .	Proc
Zero512  . . . . . . . . . . . .	Proc
push_reg . . . . . . . . . . . .	Proc


Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

kMask  . . . . . . . . . . . . .	 00000009      00000009
  b8 . . . . . . . . . . . . . .	 00000008      00000001	     0100     ?
  b7 . . . . . . . . . . . . . .	 00000007      00000001	     0080     ?
  b6 . . . . . . . . . . . . . .	 00000006      00000001	     0040     ?
  b5 . . . . . . . . . . . . . .	 00000005      00000001	     0020     ?
  b4 . . . . . . . . . . . . . .	 00000004      00000001	     0010     ?
  b3 . . . . . . . . . . . . . .	 00000003      00000001	     0008     ?
  b2 . . . . . . . . . . . . . .	 00000002      00000001	     0004     ?
  b1 . . . . . . . . . . . . . .	 00000001      00000001	     0002     ?
  b0 . . . . . . . . . . . . . .	 00000000      00000001	     0001     ?


Types:

                N a m e                  Size     Attr

LPVOID . . . . . . . . . . . . .	 00000008     PTR VOID


Segments:

                N a m e                  Length   Align   Class

ui512_shift  . . . . . . . . . .	 0000054C 16	  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

shl_u  . . . . . . . . . . . . .	P 	 000004C0 ui512_shift	Length= 0000008C Public
  @@r  . . . . . . . . . . . . .	L 	 000004EF ui512_shift	
shr_u  . . . . . . . . . . . . .	P 	 00000420 ui512_shift	Length= 0000008C Public
  @@shift  . . . . . . . . . . .	L 	 00000450 ui512_shift	


Symbols:

                N a m e                 Type     Value    Attr

B_PTR  . . . . . . . . . . . . .	Text   	 BYTE PTR
CPEQ . . . . . . . . . . . . . .	Number	 00000000h   
CPFALSE  . . . . . . . . . . . .	Number	 00000003h   
CPGE . . . . . . . . . . . . . .	Number	 00000005h   
CPGT . . . . . . . . . . . . . .	Number	 00000006h   
CPLE . . . . . . . . . . . . . .	Number	 00000002h   
CPLT . . . . . . . . . . . . . .	Number	 00000001h   
CPNE . . . . . . . . . . . . . .	Number	 00000004h   
CPTRUE . . . . . . . . . . . . .	Number	 00000007h   
D_PTR  . . . . . . . . . . . . .	Text   	 DWORD PTR
Q_PTR  . . . . . . . . . . . . .	Text   	 QWORD PTR
R8Home . . . . . . . . . . . . .	Text   	 Q_PTR [ RSP + ( 3 * 8 ) ]
R9Home . . . . . . . . . . . . .	Text   	 Q_PTR [ RSP + ( 4 * 8 ) ]
RCXHome  . . . . . . . . . . . .	Text   	 Q_PTR [ RSP + ( 1 * 8 ) ]
RDXHome  . . . . . . . . . . . .	Text   	 Q_PTR [ RSP + ( 2 * 8 ) ]
ShiftMaskLt  . . . . . . . . . .	Byte	 00000408 ui512_shift	
ShiftMaskRt  . . . . . . . . . .	Byte	 00000400 ui512_shift	
ShiftPermuteLt . . . . . . . . .	QWord	 00000200 ui512_shift	
ShiftPermuteRt . . . . . . . . .	QWord	 00000000 ui512_shift	
W_PTR  . . . . . . . . . . . . .	Text   	 WORD PTR
XM_PTR . . . . . . . . . . . . .	Text   	 XMMWORD PTR
YM_PTR . . . . . . . . . . . . .	Text   	 YMMWORD PTR
ZM_PTR . . . . . . . . . . . . .	Text   	 ZMMWORD PTR
__CheckAlign . . . . . . . . . .	Number	 00000000h   
__UseBMI2  . . . . . . . . . . .	Number	 00000001h   
__UseQ . . . . . . . . . . . . .	Number	 00000001h   
__UseX . . . . . . . . . . . . .	Number	 00000000h   
__UseY . . . . . . . . . . . . .	Number	 00000000h   
__UseZ . . . . . . . . . . . . .	Number	 00000001h   
__VerifyRegs . . . . . . . . . .	Number	 00000001h   
add_uT64 . . . . . . . . . . . .	L 	 00000000 External
add_u_wc . . . . . . . . . . . .	L 	 00000000 External
add_u  . . . . . . . . . . . . .	L 	 00000000 External
and_u  . . . . . . . . . . . . .	L 	 00000000 External
compare_uT64 . . . . . . . . . .	L 	 00000000 External
compare_u  . . . . . . . . . . .	L 	 00000000 External
compile_time_options_INC . . . .	Text   	 1
copy_u . . . . . . . . . . . . .	L 	 00000000 External
div_uT64 . . . . . . . . . . . .	L 	 00000000 External
div_u  . . . . . . . . . . . . .	L 	 00000000 External
lsb_u  . . . . . . . . . . . . .	L 	 00000000 External
m32BCST  . . . . . . . . . . . .	Text   	 DWORD BCST
m64BCST  . . . . . . . . . . . .	Text   	 QWORD BCST
msb_u  . . . . . . . . . . . . .	L 	 00000000 External
mskAll8  . . . . . . . . . . . .	DWord	 00000000 External
mskB0  . . . . . . . . . . . . .	DWord	 00000000 External
mskB1  . . . . . . . . . . . . .	DWord	 00000000 External
mskB2  . . . . . . . . . . . . .	DWord	 00000000 External
mskB3  . . . . . . . . . . . . .	DWord	 00000000 External
mskB4  . . . . . . . . . . . . .	DWord	 00000000 External
mskB5  . . . . . . . . . . . . .	DWord	 00000000 External
mskB6  . . . . . . . . . . . . .	DWord	 00000000 External
mskB7  . . . . . . . . . . . . .	DWord	 00000000 External
mult_uT64  . . . . . . . . . . .	L 	 00000000 External
mult_u . . . . . . . . . . . . .	L 	 00000000 External
not_u  . . . . . . . . . . . . .	L 	 00000000 External
or_u . . . . . . . . . . . . . .	L 	 00000000 External
qOnes  . . . . . . . . . . . . .	QWord	 00000000 External
qZero  . . . . . . . . . . . . .	QWord	 00000000 External
reg_verify . . . . . . . . . . .	L 	 00000000 External
ret_GPFault  . . . . . . . . . .	DWord	 00000000 External
ret_neg_one  . . . . . . . . . .	DWord	 00000000 External
ret_one  . . . . . . . . . . . .	DWord	 00000000 External
ret_zero . . . . . . . . . . . .	DWord	 00000000 External
retcode_neg_one  . . . . . . . .	Number	 -00000001h   
retcode_one  . . . . . . . . . .	Number	 00000001h   
retcode_zero . . . . . . . . . .	Number	 00000000h   
set_uT64 . . . . . . . . . . . .	L 	 00000000 External
sub_uT64 . . . . . . . . . . . .	L 	 00000000 External
sub_u_wb . . . . . . . . . . . .	L 	 00000000 External
sub_u  . . . . . . . . . . . . .	L 	 00000000 External
ui512_externs_INC  . . . . . . .	Text   	 1
ui512_legalnotes_INC . . . . . .	Number	 00000001h   
ui512_macros_INC . . . . . . . .	Text   	 1
xor_u  . . . . . . . . . . . . .	L 	 00000000 External
zero_u . . . . . . . . . . . . .	L 	 00000000 External

	   0 Warnings
	   0 Errors
