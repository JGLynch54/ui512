Microsoft (R) Macro Assembler (x64) Version 14.50.35721.0   12/29/25 19:46:08
ui512_multiply.asm					     Page 1 - 1


				;
				;			ui512_multiply
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;
				;			File:			ui512_multiply.asm
				;			Author:			John G. Lynch
				;			Legal:			Copyright @2024, per MIT License below
				;			Date:			October 29, 2025

								INCLUDE			ui512_legalnotes.inc
			      C ;
			      C ;			ui512 Legal Notes
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			File:			ui512_legalnotes.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright 2025, per MIT License included
			      C ;			Date:			Octoberr 24, 2025
			      C ;
			      C IFNDEF							ui512_legalnotes_INC
 = 00000001		      C ui512_legalnotes_INC			EQU		1
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			Notes:
			      C ;				ui512 is a small project to provide basic operations for a variable type of unsigned 512 bit integer.
			      C ;
			      C ;				ui512a provides basic operations: zero, copy, compare, add, subtract.
			      C ;				ui512b provides basic bit-oriented operations: shift left, shift right, and, or, not, least significant bit and most significant bit.
			      C ;               ui512md provides multiply and divide.
			      C ;
			      C ;				It is written in assembly language, using the MASM (ml64) assembler provided as an option within Visual Studio.
			      C ;				(currently using VS Community 2022 17.14.10)
			      C ;
			      C ;				It provides external signatures that allow linkage to C and C++ programs,
			      C ;				where a shell/wrapper could encapsulate the methods as part of an object.
			      C ;
			      C ;				Note: X64 ZMM regs are "little-endian". The 8 QWORD C array declarion is "big-endian".
			      C ;				In memory the most significant word is first: var[0], the least last var[7]. Normally not an issue,
			      C ;				but when that var is laoded in a Z-reg, the least significant is first, and the most last, which is
			      C ;				the way z-regs are loaded, but convention has the z-reg first word commonly termed the most significant, 
			      C ;				which is not the way our c arrays are defined. Not an issue programmatically, but often a qword shift left, or right
			      C ;				or a carry or borrow to the next most significant word is not the same when the data is in a z-reg.
			      C ;
			      C ;				It has assembly time options directing the use of Intel processor extensions: AVX4, AVX2, SIMD, or none:
			      C ;				(Z (512), Y (256), or X (128) registers, or regular Q (64bit)).
			      C ;
			      C ;				Note: The file "compile_time_options.inc" contains the options that can be configured for extension usage, and other options.
			      C ;
			      C ;				If processor extensions are used, the caller must align the variables declared and passed
			      C ;				on the appropriate byte boundary (e.g. alignas 64 for 512)
			      C ;
			      C ;				The modules (in total) are very light-weight (less than 10K bytes) and relatively fast,
			      C ;				but is not intended for all processor types or all environments. 
			      C ;
			      C ;				Intended use cases:
			      C ;					1.) a "sum of primes" for primes up to 2^48. 
			      C ;					2.) elliptical curve cryptography (ECC)
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			MIT License
			      C ;
			      C ;			Copyright (c) 2024 John G. Lynch
			      C ;
			      C ;				Permission is hereby granted, free of charge, to any person obtaining a copy
			      C ;				of this software and associated documentation files (the "Software"), to deal
			      C ;				in the Software without restriction, including without limitation the rights
			      C ;				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			      C ;				copies of the Software, and to permit persons to whom the Software is
			      C ;				furnished to do so, subject to the following conditions:
			      C ;
			      C ;				The above copyright notice and this permission notice shall be included in all
			      C ;				copies or substantial portions of the Software.
			      C ;
			      C ;				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			      C ;				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			      C ;				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			      C ;				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			      C ;				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			      C ;				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			      C ;				SOFTWARE.
			      C ;
			      C ENDIF			; ui512_legalnotes_INC
			      C 
								INCLUDE			ui512_compile_time_options.inc
			      C ;
			      C ;			ui512_compile_time_options
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			File:			ui512_compile_time_options.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2025, per MIT License included
			      C ;			Date:			August 20, 2025 (file creation)
			      C ;
			      C IFNDEF							compile_time_options_INC
 = 1			      C compile_time_options_INC		EQU			<1>
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Configuration choices
			      C ;
			      C ;	Note: Choosing these options requires knowledge of the target machine CPU model. If you are unsure of the capabiites of the target machine CPU,
			      C ;	You can use the "CPU-Z" tool. https://www.cpuid.com/downloads/cpu-z/cpu-z_2.09-en.exe 
			      C ;	Basically, Intel Skylake and later can use "Z", Haswell and later can use BMI2, etc. 
			      C ;	Too many processors, options, vendors for me to list here. Go to the CPU vendor specifications, or use the tool to inform your choice.
			      C ;
			      C ;	Note: This is intended to be a mutually exclusive choice (UseZ thru UseQ).
			      C ;	However, the coding of the options selects the "highest" one used and ignores the rest ( If __UseZ ... ELSEIF __UseY ... )
			      C 
 = 00000001		      C __UseZ			EQU				1									; Use AVX4 processor features (512 bit registers and instructions)
 = 00000000		      C __UseY			EQU				0									; Use AVX2 processor features (256 bit registers and instructions)
 = 00000000		      C __UseX			EQU				0									; Use SIMD/SSE processor features (128 bit registers and instructions)
 = 00000001		      C __UseQ			EQU				1									; Do not use extensions, use standard x64 bit registers and instructions
			      C ;
 = 00000001		      C __UseBMI2		EQU				1									; Bit manipulation instructions (Haswell and later) ref:https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set
			      C ;
 = 00000001		      C __VerifyRegs	EQU				1									; in debug mode, or with unit tests, define routine to verify non-volatile regs 
 = 00000000		      C __CheckAlign	EQU				0									; User is expected to pass arguments aligned on 64 byte boundaries, 
			      C ;																	; This setting enforces that with a check. It should not be necessary, but included to help debugging
			      C 
			      C ENDIF			; ui512_compile_time_options_INC
			      C 
								INCLUDE			ui512_macros.inc
			      C ;
			      C ;			ui512 Macros
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			File:			ui512_macros.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2025, per MIT License included
			      C ;			Date:			October 24, 2025  (file creation)
			      C ;
			      C IFNDEF							ui512_macros_INC
 = 1			      C ui512_macros_INC				EQU		<1>
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ; Some coding shortcuts
			      C ;
 = ZMMWORD PTR		      C ZM_PTR			EQU				ZMMWORD PTR 
 = YMMWORD PTR		      C YM_PTR			EQU				YMMWORD PTR
 = XMMWORD PTR		      C XM_PTR			EQU				XMMWORD PTR
 = QWORD PTR		      C Q_PTR			EQU				QWORD PTR
 = DWORD PTR		      C D_PTR			EQU				DWORD PTR
 = WORD PTR		      C W_PTR			EQU				WORD PTR
 = BYTE PTR		      C B_PTR			EQU				BYTE PTR
 = DWORD BCST		      C m32BCST			EQU				DWORD BCST
 = QWORD BCST		      C m64BCST			EQU				QWORD BCST
			      C LPVOID			TYPEDEF			PTR VOID
			      C 
			      C ; Mask codes (for compares using instructions like VPCMPUQ)
 = 00000000		      C CPEQ			EQU				0
 = 00000001		      C CPLT			EQU				1
 = 00000002		      C CPLE			EQU				2
 = 00000003		      C CPFALSE			EQU				3
 = 00000004		      C CPNE			EQU				4
 = 00000005		      C CPGE			EQU				5
 = 00000006		      C CPGT			EQU				6
 = 00000007		      C CPTRUE			EQU				7
			      C 
			      C ; Masks commonly used: here in Record form, which can be used as immediate values. Example: OR	R8D, MASK kMask.b8
			      C kMask			RECORD			b8:1, b7:1, b6:1, b5:1, b4:1, b3:1, b2:1, b1:1, b0:1
			      C 
			      C ; Return codes commonly used.	
 = 00000000		      C retcode_zero	EQU				0
 = 00000001		      C retcode_one		EQU				1
 =-00000001		      C retcode_neg_one	EQU				-1
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;           Notes on x64 calling conventions        specifically "fast call"
			      C ; ref: https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170
			      C ; The callers first four parameters are passed in registers: RCX, RDX, R8, R9 if integer or address; if floating point XMM0L, XMM1L, XMM2L, XMM3L
			      C ; return (if any) is in EAX
			      C ;
			      C ; RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile, and do not need to be saved
			      C ; XMM0, YMM0, ZMM0 and  ..1, ..2, ..3, ..4, and ..5 are considered volatile, and do not need to be saved
			      C ; ZMM16 to ZMM31: volatile, also do not need to be zeroed to resume full clock speeds
			      C ;
			      C ; R12, R13, R14, R15, RDI, RSI, RBX, RBP, RSP are non-volatile and if used, must be restored
			      C ; XMM, YMM, and ZMM ..6 thru 15 are non-volatile and if used, must be restored
			      C ;
			      C ; A "leaf" function is one that does not call and does not change non volatile registers
			      C ; leaf functionss therefore do not need frame, prolog or epilog
			      C ;
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; Selected macros from "macamd64.inc" (c) Microsoft Corporation
			      C ;	These macros generate .xdata and .pdata entries in the executable image file.
			      C ;	The entries assist in exception and debugging; helping 'unwind' operations.
			      C ;	Only a few macros are included, and are reformatted to match coding style:;	indents and capitalization.
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; Leaf_Entry <Name>
			      C ;
			      C ; Macro Description:
			      C ;   This macro indicates the beginning of a leaf function.;
			      C ;
			      C ; Arguments:
			      C ;   Name - Supplies the name of the function
			      C ;   
			      C Leaf_Entry		MACRO			Name
			      C 				DB				6 DUP (0cch)
			      C 				ALIGN			16
			      C 				PUBLIC			Name
			      C Name			PROC
			      C ; Addresses of param regs "home" after reg pushs, and _allocspace adjust
			      C RCXHome			EQU				Q_PTR [ RSP + ( 1 * 8 ) ]	
			      C RDXHome			EQU				Q_PTR [ RSP + ( 2 * 8 ) ]
			      C R8Home			EQU				Q_PTR [ RSP + ( 3 * 8 ) ]
			      C R9Home			EQU				Q_PTR [ RSP + ( 4 * 8 ) ]
			      C 				ENDM
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; Proc_w_Local	ProcName, LocalStructName, NV_Regs_Used:vararg
			      C ;
			      C Proc_w_Local	MACRO			ProcName, LocalStructName, NV_Regs_Used:vararg
			      C 
			      C _shadowspace	EQU				40h								; stack space for caller (at top) and callee (at bottom)
			      C _localspace		=				sizeof (LocalStructName)		; space needed (on stack) for local variables
			      C _alignspace		EQU				64								; amount of space that might get truncated to get frame space aligned on specified boundary (64)
			      C _allocspace		=				_localspace + ( 2 * _shadowspace) + _alignspace	; calculate total stack space to allocate.
			      C 
			      C 				DB				6 DUP (0cch)
			      C 				ALIGN			16
			      C 				PUBLIC			ProcName						; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
			      C ProcName		PROC			FRAME
			      C 				
			      C 				MOV				[ RSP + ( 1 * 8) ], RCX
			      C 				push_reg        RBP								; standard prologue code
			      C 
			      C 	nRegs = 1
			      C 				FOR				reg, <NV_Regs_Used>				; save specified non-volatile regs on stack (in top shadowspace)
			      C 				push_reg		reg
			      C 	nRegs = nRegs + 1
			      C 				ENDM
			      C 
			      C 				SUB				RSP, _allocspace				; set stack pointer down by space needed (locals+ (2 * shadowspace))
			      C 				.ALLOCSTACK		_allocspace
			      C 	
			      C ; set frame pointer within new space, but above shadowspace
			      C 				LEA				RBP, ( _shadowspace + _alignspace ) [ RSP ]
			      C 				AND				RBP, -_alignspace				; truncate low bits of base pointer to yield aligned pointer
			      C 
			      C 				.ENDPROLOG
			      C ; Addresses of param regs "home" after reg pushs, and _allocspace adjust
			      C RCXHome			EQU				Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 1 ) * 8 ) ) ]
			      C RDXHome			EQU				Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 2 ) * 8 ) ) ] 
			      C R8Home			EQU				Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 3 ) * 8 ) ) ]
			      C R9Home			EQU				Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 4 ) * 8 ) ) ]
			      C l_Ptr			EQU				[RBP] + LocalStructName			; set up shortcut for accessing local data structure
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; Local_Exit	NV_Regs_Used:vararg
			      C ;
			      C Local_Exit		MACRO			NV_Regs_Used:vararg
			      C 				ADD				RSP,  _allocspace
			      C 				FOR				reg, <NV_Regs_Used>
			      C 				POP				reg
			      C 				ENDM 
			      C 				POP				RBP
			      C 				RET
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; push_reg	reg (non-volatile) to push
			      C ;
			      C push_reg		MACRO			reg
			      C 				PUSH			reg
			      C 				.PUSHREG		reg
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; CheckAlign <RAddr>
			      C ;
			      C ;			Test passed variable addresses for 64 byte alignment
			      C ;			Note: Better performance if this is off, but for debugging, maybe have it on
			      C ;
			      C CheckAlign		MACRO			Raddr:REQ, ExitLbl:VARARG
			      C 	IF	__CheckAlign
			      C 				TEST			Raddr, 63							; Is specified param aligned 64?
			      C 				JZ				@F									; Yes, passes test, continue
			      C 				MOV				EAX, 0C0000005h						; Windows code for General Protection Fault	
			      C 		IFNB	<ExitLbl>
			      C 				JMP				ExitLbl								; Return to caller, with GPFault code in EAX
			      C 		ELSE
			      C 				RET													; No, fault return with err code
			      C 		ENDIF
			      C @@:
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Zero a 512 bit destination, conditional assembly based on configuration parameters
			      C ;
			      C Zero512			MACRO			dest:REQ
			      C 	IF		__UseZ
			      C 				CheckAlign		dest
			      C 				VPXORQ			ZMM31, ZMM31, ZMM31
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				VPXORQ			YMM4, YMM4, YMM4
			      C 				FOR				idx, < 0, 4 >
			      C 				VMOVDQA64		YM_PTR [ dest ] [ idx * 8 ], YMM4
			      C 				ENDM
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				PXOR			XMM4, XMM4
			      C 				FOR				idx, < 0, 2, 4, 6 >
			      C 				MOVDQA			XM_PTR [ dest ] [ idx * 8 ], XMM4
			      C 				ENDM		
			      C 	ELSE
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Zero a 512 bit destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Zero512Q		MACRO			dest:REQ
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Copy a 512 bit source to destination, conditional assembly based on configuration parameters
			      C ;
			      C Copy512			MACRO			dest:REQ, src:REQ
			      C 	IF		__UseZ 
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		ZMM31, ZM_PTR [ src ]
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		YMM4, YM_PTR [ src + 0 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			      C 				VMOVDQA64		YMM5, YM_PTR [ src ] [ 4 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 4 * 8 ], YMM5
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 0 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 0 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 2 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 2 * 8 ], XMM3
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 4 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 4 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 6 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 6 * 8 ], XMM3
			      C 	ELSE
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Copy a 512 bit source to destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Copy512Q		MACRO			dest:REQ, src:REQ
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;	VerifyRegs <none>
			      C ;
			      C ;			If option is on, generate a function, callable by unit test routines, 
			      C ;				to save non-volatile registers in passed structure.
			      C ;
			      C IF	__VerifyRegs
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* regstruct)
			      C ;			reg_verify		-	copy non-volatile regs into callers struct of nine qwords) intended for unit tests to verify non-volatile regs are not changed
			      C ;			Prototype:		-	void reg_verify( uu64* regstruct);
			      C ;			regstruct		-	Address of 9 QWORDS in a struct where regs will be copied (in RCX)
			      C ; //			reg_verify		-	save non-volatile regs for verification (debug)
			      C ; //			Prototype		-	void reg_verify ( u64* reg struct)
			      C 
			      C EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* reg struct)
			      C 
			      C VerifyRegs		MACRO
			      C 				Leaf_Entry		reg_verify
			      C 				MOV				Q_PTR [ RCX ] [ 0 * 8 ], R12
			      C 				MOV				Q_PTR [ RCX ] [ 1 * 8 ], R13
			      C 				MOV				Q_PTR [ RCX ] [ 2 * 8 ], R14
			      C 				MOV				Q_PTR [ RCX ] [ 3 * 8 ], R15
			      C 				MOV				Q_PTR [ RCX ] [ 4 * 8 ], RDI
			      C 				MOV				Q_PTR [ RCX ] [ 5 * 8 ], RSI
			      C 				MOV				Q_PTR [ RCX ] [ 6 * 8 ], RBX
			      C 				MOV				Q_PTR [ RCX ] [ 7 * 8 ], RBP
			      C 				MOV				Q_PTR [ RCX ] [ 8 * 8 ], RSP
			      C 				RET
			      C reg_verify		ENDP
			      C 				ENDM
			      C ENDIF
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Get a GP reg QWORD from within a Z register as specified by mask
			      C ;			Note: RAX, ZMM0 and k1 are used and not restored
			      C ;			Example usage: GetZatIdx R11, ZMM1, MaskBit2 or SetZatIdx ZMM1, R12, [ R9 ]  (where R9 is a bit mask, not an integer index)
			      C ;			Note: These are req to reg ops; no memory fetches (other than instructions from pipeline)
			      C ;
			      C GetZatMask		MACRO			dest, src, mask
			      C 				LEA				RAX,  mask
			      C 				KMOVB			k1, RAX
			      C 				VPCOMPRESSQ		ZMM0 {k1}{z}, src
			      C 				VMOVQ			dest, XMM0
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Set a GP Reg QWORD within a Z register as specified by mask
			      C ;			Note: RAX and k1 are used and not restored
			      C ;			Example usage: SetZatIdx ZMM1, R8, MaskBit2
			      C ;			Note: These are req to reg ops; no memory fetches (other than instructions from pipeline)
			      C ;
			      C SetZatMask		MACRO			dest, src, mask
			      C 				LEA				RAX, mask
			      C 				KMOVB			k1, RAX
			      C 				VPBROADCASTQ 	dest {k1}, src
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ENDIF			; ui512_macros_INC
			      C 
								INCLUDE			ui512_externs.inc
			      C ;
			      C ;			ui512 Externs
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			File:			ui512_externs.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2025, per MIT License included
			      C ;			Date:			October 24, 2025
			      C ;
			      C IFNDEF							ui512_externs_INC
 = 1			      C ui512_externs_INC				EQU		<1>
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;   header file equivalent extern declarations
			      C ;			EXTERN "C" signatures 
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_clear_copy_set.asm:
			      C ;
			      C ;	// void zero_u ( u64* destarr ); 
			      C ;	// fill supplied 512bit (8 QWORDS) with zero
			      C EXTERNDEF		zero_u:PROC
			      C 
			      C ;	// void copy_u ( u64* destarr, u64* srcarr );
			      C ;	// copy supplied 512bit (8 QWORDS) source to supplied destination
			      C EXTERNDEF		copy_u:PROC
			      C 
			      C ;	// void set_uT64 ( u64* destarr, u64 value );
			      C ;	// set supplied destination 512 bit to supplied u64 value
			      C EXTERNDEF		set_uT64:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_compare.asm
			      C ;
			      C ;	// s16 compare_u ( u64* lh_op, u64* rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied RH operand
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_u:PROC
			      C 
			      C ;	// s16 compare_uT64 ( u64* lh_op, u64 rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied 64bit RH operand (value)
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_uT64:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_addition.asm
			      C ;
			      C ;	// s16 add_u ( u64* sum, u64* addend1, u64* addend2 );
			      C ;	// add supplied 512bit (8 QWORDS) sources, place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_u:PROC
			      C 
			      C ;	// s16 add_u_wc ( u64* sum, u64* addend1, u64* addend2, s16 carry );
			      C ;	// add supplied 512bit (8 QWORDS) sources, with passed-in carry, place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_u_wc:PROC
			      C 
			      C ;	// s16 add_uT64 ( u64* sum, u64* addend1, u64 addend2 );
			      C ;	// add 64bit QWORD (value) to supplied 512bit (8 QWORDS), place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_uT64:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_subtraction.asm
			      C ;
			      C ;	// s16 sub_u ( u64* difference, u64* left operand, u64* right operand );
			      C ;	// subtract supplied 512bit (8 QWORDS) RH OP from LH OP giving difference in destination
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_u:PROC
			      C 
			      C ;	// s16 sub_u_wc ( u64* difference, u64* left operand, u64* right operand, s16 borrow );
			      C ;	// subtract supplied 512bit (8 QWORDS) RH OP from LH OP, with passed-in borrow giving difference in destination
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_u_wb:PROC
			      C 
			      C ;	// s16 sub_uT64( u64* difference, u64* left operand, u64 right operand );
			      C ;	// subtract supplied 64 bit right hand (64 bit value) op from left hand (512 bit) giving difference
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_uT64:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_multiply.asm
			      C ;
			      C ; //			mult_uT64		-	multiply 512 bit multiplicand by 64 bit multiplier, giving 512 product, 64 bit overflow
			      C ; //			Prototype:		-	s16 mult_uT64( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
			      C EXTERNDEF		mult_uT64:PROC	;	s16 mult_uT64( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
			      C 
			      C ; //			mult_u			-	multiply 512 multiplicand by 512 multiplier, giving 512 product, overflow
			      C ; //			Prototype:		-	s16 mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier);
			      C EXTERNDEF		mult_u:PROC		;	s16 mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier);
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_division.asm
			      C ;
			      C ; //			div_uT64		-	divide 512 bit dividend by 64 bit bit divisor, giving 512 bit quotient and 64 bit remainder
			      C ; //			Prototype:		-	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64 divisor,);
			      C EXTERNDEF		div_uT64:PROC	;	s16 div_uT64( u64* quotient, u64* remainder, u64* dividend, u64 divisor);
			      C 
			      C ; //			div_u			-	divide 512 bit dividend by 512 bit divisor, giving 512 bit quotient and remainder
			      C ; //			Prototype:		-	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor);
			      C EXTERNDEF		div_u:PROC		;	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor);
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_significance.asm
			      C 
			      C ;   // find most significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 msb_u( u64* );
			      C ;   // returns: -1 if no most significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C ;	//	Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit).
			      C ;	//			a returned 511 means bit63 of the first word; (the left most bit).	
			      C EXTERNDEF		msb_u:PROC
			      C 
			      C ;   // find least significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 lsb_u( u64* );
			      C ;   // returns: -1 if no least significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C ;	//	Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit).
			      C ;	//			a returned 511 means bit63 of the first word; (the left most bit).	
			      C EXTERNDEF		lsb_u:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_shift.asm
			      C ;
			      C ;   // void shr_u ( u64* destination, u64* source, u16 bits_to_shift )
			      C ;   // shift supplied source 512bit (8 QWORDS) right, put in destination
			      C EXTERNDEF		shr_u:PROC
			      C 
			      C ;   // void shl_u ( u64* destination, u64* source, u16 bits_to_shift );
			      C ;   // shift supplied source 512bit (8 QWORDS) left, put in destination
			      C EXTERNDEF		shl_u:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_bitops
			      C ;
			      C ;   // void and_u ( u64* destination, u64* lh_op, u64* rh_op );
			      C ;   // logical 'AND' bits in lh_op, rh_op, put result in destination
			      C EXTERNDEF		and_u:PROC
			      C 
			      C ;   // logical 'OR' bits in lh_op, rh_op, put result in destination
			      C ;   // void or_u( u64* destination, u64* lh_op, u64* rh_op);
			      C EXTERNDEF		or_u:PROC
			      C 
			      C ;   // logical 'XOR' bits in lh_op, rh_op, put result in destination
			      C ;   // void xor_u( u64* destination, u64* lh_op, u64* rh_op);
			      C EXTERNDEF		xor_u:PROC
			      C 
			      C ;   // logical 'NOT' bits in source, put result in destination
			      C ;	// void not_u( u64* destination, u64* source);
			      C EXTERNDEF		not_u:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_global_data
			      C ;
			      C EXTERNDEF		qOnes:QWORD
			      C EXTERNDEF		qZero:QWORD
			      C 
			      C EXTERNDEF		ret_zero:DWORD
			      C EXTERNDEF		ret_one:DWORD
			      C EXTERNDEF		ret_neg_one:DWORD
			      C EXTERNDEF		ret_GPFault:DWORD
			      C 
			      C EXTERNDEF		mskB0:DB
			      C EXTERNDEF		mskB1:DB
			      C EXTERNDEF		mskB2:DB
			      C EXTERNDEF		mskB3:DB
			      C EXTERNDEF		mskB4:DB
			      C EXTERNDEF		mskB5:DB
			      C EXTERNDEF		mskB6:DB
			      C EXTERNDEF		mskB7:DB
			      C EXTERNDEF		mskAll8:DB
			      C 
			      C ENDIF			; ui512_externs_INC
			      C 
			      C 
				.NOLISTIF
								OPTION			CASEMAP:NONE
 00000000			ui512_multiply	SEGMENT			PARA 'CODE'

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			EXTERNDEF		mult_u:PROC					; s16 mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier)
				;			mult_u			-	multiply 512 multiplicand by 512 multiplier, giving 512 product, 512 overflow
				;			Prototype:		-	s16 mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier);
				;			product			-	Address of 8 QWORDS to store resulting product (in RCX)
				;			overflow		-	Address of 8 QWORDS to store resulting overflow (in RDX)
				;			multiplicand	-	Address of 8 QWORDS multiplicand (in R8)
				;			multiplier		-	Address of 8 QWORDS multiplier (in R9)
				;			returns			-	(0) for success, (GP_Fault) for mis-aligned parameter address
				;
								
 00000080			mult_u_Locals	STRUCT
 00000000  00000010 [		product			QWORD			16 dup (?)
	    0000000000000000
	   ]
				mult_u_Locals	ENDS

				; Declare proc, save regs, set up frame
								Proc_w_Local	mult_u, mult_u_Locals, R12, R13, R14, R15
 = 00000040		     1	_shadowspace	EQU				40h								; stack space for caller (at top) and callee (at bottom)
 = 00000040		     1	_alignspace		EQU				64								; amount of space that might get truncated to get frame space aligned on specified boundary (64)
 00000000  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000010		     1	mult_u		PROC			FRAME
 00000010  48/ 89 4C 24	     1					MOV				[ RSP + ( 1 * 8) ], RCX
	   08
 00000015  55		     2					PUSH			RBP
 00000016  41/ 54	     3					PUSH			R12
 00000018  41/ 55	     3					PUSH			R13
 0000001A  41/ 56	     3					PUSH			R14
 0000001C  41/ 57	     3					PUSH			R15
 0000001E  48/ 81 EC	     1					SUB				RSP, _allocspace				; set stack pointer down by space needed (locals+ (2 * shadowspace))
	   00000140
 00000025  48/ 8D AC 24	     1					LEA				RBP, ( _shadowspace + _alignspace ) [ RSP ]
	   00000080
 0000002D  48/ 83 E5 C0	     1					AND				RBP, -_alignspace				; truncate low bits of base pointer to yield aligned pointer
 00000031  48/ 89 8C 24						MOV				RCXHome, RCX
	   00000170
 00000039  48/ 89 94 24						MOV				RDXHome, RDX
	   00000178

				; Check passed parameters alignment, since this is checked within frame, need to specify exit / cleanup / unwrap label
								CheckAlign		RCX, @@exit							; (out) Product
								CheckAlign		RDX, @@exit							; (out) Overflow
								CheckAlign		R8, @@exit							; (in) Multiplicand
								CheckAlign		R9, @@exit							; (in) Multiplier

				; Examine multiplicand, save dimensions, handle edge cases of zero or one
 00000041  49/ 8B C8						MOV				RCX, R8								; examine multiplicand
 00000044  E8 00000000 E					CALL			msb_u								; get count to most significant bit (-1 if no bits)
 00000049  85 C0						TEST			EAX, EAX								
 0000004B  0F 8C 000000E9					JL				@@zeroandexit						; msb < 0? multiplicand = 0; exit with product = 0
 00000051  49/ 8D 11						LEA				RDX, [ R9 ]							; multiplicand = 1?	exit with product = multiplier -> address of multiplier (to be copied to product)
 00000054  0F 84 0000010A					JE				@@copyandexit						; msb = 0 means lowest bit, or multiplicand == 1 -> copy multiplier to product and exit
 0000005A  C1 E8 06						SHR				EAX, 6								; divide msb by 64 to get Nr words
 0000005D  44/ 8D 34 25						LEA				R14D, [ 7 ]							; subtract from 7 to get starting (high order, left-most) beginning index
	   00000007
 00000065  44/ 2B F0						SUB				R14D, EAX							; save in scratch reg (R14) as multiplicand index lower limit (eliminate multiplying leading zero words)	

				; Examine multiplier, save dimensions, handle edge cases of zero or one
 00000068  49/ 8B C9						MOV				RCX, R9								; examine multiplier
 0000006B  E8 00000000 E					CALL			msb_u								; get count to most significant bit (-1 if no bits)
 00000070  85 C0						TEST			EAX, EAX							; 
 00000072  0F 8C 000000C2					JL				@@zeroandexit						; return -1? means multiplier == 0 -> exit with product = 0
 00000078  49/ 8D 10						LEA				RDX, [ R8 ]							; 
 0000007B  0F 84 000000E3					JE				@@copyandexit						; multiplier = 1? exit with product = multiplicand -> address of multiplicand (to be copied to product)
 00000081  C1 E8 06						SHR				EAX, 6								; divide msb by 64 to get Nr words
 00000084  44/ 8D 3C 25						LEA				R15D, [ 7 ]							; subtract from 7 to get starting (high order, left-most) beginning index
	   00000007
 0000008C  44/ 2B F8						SUB				R15D, EAX							; save off multiplier index lower limit (eliminate multiplying leading zero words)	(R15)					

				; In frame / stack reserved memory, clear 16 qword area for working version of overflow/product; set up indexes for loop				
					IF __UseQ
 0000008F  62 01 85 40/ EF					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000095  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR l_Ptr.product, ZMM31
	   7D 00
 0000009C  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR l_Ptr.product + [ 8 * 8 ], ZMM31
	   7D 01
					ELSE
					ENDIF
 000000A3  4C/ 8D 1C 25						LEA				R11	, [ 7 ] 						; index for multiplier (reduced until less than saved multiplier lower limit (R15W) (outer loop)
	   00000007
 000000AB  4D/ 8B E3						MOV				R12, R11							; index for multiplicand (reduced until less than saved multiplicand lower limit (R14W) (inner loop)

				; multiply loop: an outer loop for each non-leading-zero qword of multiplicand,
				; with an inner loop for each non-leading-zero qword of multiplier, results accumulated in 'overflow/product' local copy 
								ALIGN												; start (both inner and outer) loop aligned
 000000B0  4F/ 8D 54 23		@@multloop:		LEA				R10,  1 [ R11 ] [ R12]				; R10 now holds index for overflow / product work area (results)
	   01
 000000B5  4B/ 8B 04 E0						MOV				RAX, Q_PTR [ R8 ] [ R12 * 8 ]		; get qword of multiplicand
 000000B9  48/ 85 C0						TEST			RAX, RAX							; skip multiply if zero
 000000BC  74 20						JZ				@@nextmult
 000000BE  4B/ F7 24 D9						MUL				Q_PTR [ R9 ] [ R11 * 8 ]			; multiply by qword of multiplier
 000000C2  4A/ 01 44 D5						ADD				l_Ptr.product [ R10 * 8 ], RAX			; accummulate in product [R10], this is low-order 64 bits of result of mul
	   00
 000000C7  49/ FF CA						DEC				R10									; index for overflow / product area, decrement and preserve carry flag
 000000CA  4A/ 11 54 D5		@@:				ADC				l_Ptr.product [ R10 * 8 ], RDX		; high-order result of 64bit multiply, plus the carry (if any)
	   00
 000000CF  73 0D						JNC				@@nextmult									; if adding caused carry, propagate it, else next 
 000000D1  48/ 8D 14 25						LEA				RDX, [ 0 ]							; if propagating, add zero plus carry. preserve carry flag
	   00000000
 000000D9  49/ FF CA						DEC				R10									; propagating carry
 000000DC  7D EC						JGE				@B
 000000DE  41/ FF CC		@@nextmult:		DEC				R12D								; index to next qword of multiplicand
 000000E1  45/ 3B E6						CMP				R12D, R14D							; Done with inner loop? R14W has multiplicand index lower limit 
 000000E4  7D CA						JGE				@@multloop							; no -> do it again
 000000E6  44/ 8D 24 25						LEA				R12D, [ 7 ]							; yes, reset inner loop (multiplicand) index
	   00000007
 000000EE  41/ FF CB						DEC				R11D								; decrement index for outer loop
 000000F1  45/ 3B DF						CMP				R11D, R15D							; done with outer loop? R15W has multiplier index lower limit
 000000F4  7D BA						JGE				@@multloop							; no, do it again with next qword of multiplier

				; finished: copy working product/overflow to callers product/overflow
 000000F6  48/ 8B 8C 24						MOV				RCX, RCXHome						; parameter passed as addr of callers product
	   00000170
 000000FE  48/ 8D 55 40						LEA				RDX, l_Ptr.product [ 8 * 8 ]
								Copy512			RCX, RDX							; copy working product to callers product
 00000102  62 61 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 00000108  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 0000010E  48/ 8B 8C 24						MOV				RCX, RDXHome						; parameter passed as addr of callers overflow
	   00000178
 00000116  48/ 8D 55 00						LEA				RDX, l_Ptr.product [ 0 ]
								Copy512			RCX, RDX							; copy working overflow to callers overflow
 0000011A  62 61 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 00000120  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39

				; restore regs, release frame, return
 00000126  48/ 33 C0		@@exit:			XOR				RAX, RAX							; return zero
								Local_Exit		R15, R14, R13, R12				
 00000129  48/ 81 C4	     1					ADD				RSP,  _allocspace
	   00000140
 00000130  41/ 5F	     2					POP				R15
 00000132  41/ 5E	     2					POP				R14
 00000134  41/ 5D	     2					POP				R13
 00000136  41/ 5C	     2					POP				R12
 00000138  5D		     1					POP				RBP
 00000139  C3		     1					RET

				; multiplying by 0: zero callers product and overflow
 0000013A  48/ 8B 8C 24		@@zeroandexit:	MOV				RCX, RCXHome						; reload address of callers product
	   00000170
								Zero512			RCX									; zero it
 00000142  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000148  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 0000014E  48/ 8B 8C 24						MOV				RCX, RDXHome						; reload address of caller overflow
	   00000178
								Zero512			RCX									; zero it
 00000156  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 0000015C  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 00000162  EB C2						JMP				@@exit

				; multiplying by 1: zero overflow, copy the non-one (multiplier or multiplicand) to the product
 00000164  48/ 8B 8C 24		@@copyandexit:	MOV				RCX, RDXHome						; address of passed overflow
	   00000178
								Zero512			RCX 								; zero it
 0000016C  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000172  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 00000178  48/ 8B 8C 24						MOV				RCX, RCXHome						; copy (whichever: multiplier or multiplicand) to callers product
	   00000170
								Copy512			RCX, RDX							; RDX "passed" here from the jump here (either &multiplier, or &multiplicand in RDX)
 00000180  62 61 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ RDX ]
	   3A
 00000186  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 0000018C  EB 98						JMP				@@exit								; and exit				
 0000018E			mult_u			ENDP				

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			EXTERNDEF		mult_uT64:PROC				;	s16 mult_uT64( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
				;			mult_uT64		-	multiply 512 bit multiplicand by 64 bit multiplier, giving 512 product, 64 bit overflow
				;			Prototype:		-	s16 mult_uT64( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
				;			product			-	Address of 8 QWORDS to store resulting product (in RCX)
				;			overflow		-	Address of QWORD for resulting overflow (in RDX)
				;			multiplicand	-	Address of 8 QWORDS multiplicand (in R8)
				;			multiplier		-	multiplier QWORD (in R9)
				;			returns			-	(0) for success, (GP_Fault) for mis-aligned parameter address

				; Declare structure of local variables (will become part of stack-based frame) (thread-safe)
 00000040			mult64_Locals	STRUCT
 00000000  00000008 [		multiplicand	QWORD			8 dup (?)
	    0000000000000000
	   ]
				mult64_Locals	ENDS

				; Declare proc, save regs, set up frame
								Proc_w_Local	mult_uT64, mult64_Locals
 = 00000040		     1	_shadowspace	EQU				40h								; stack space for caller (at top) and callee (at bottom)
 = 00000040		     1	_alignspace		EQU				64								; amount of space that might get truncated to get frame space aligned on specified boundary (64)
 0000018E  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 000001A0		     1	mult_uT64		PROC			FRAME
 000001A0  48/ 89 4C 24	     1					MOV				[ RSP + ( 1 * 8) ], RCX
	   08
 000001A5  55		     2					PUSH			RBP
 000001A6  48/ 81 EC	     1					SUB				RSP, _allocspace				; set stack pointer down by space needed (locals+ (2 * shadowspace))
	   00000100
 000001AD  48/ 8D AC 24	     1					LEA				RBP, ( _shadowspace + _alignspace ) [ RSP ]
	   00000080
 000001B5  48/ 83 E5 C0	     1					AND				RBP, -_alignspace				; truncate low bits of base pointer to yield aligned pointer

				; Check passed parameters alignment, since this is checked within frame, need to specify exit / cleanup / unwrap label
								CheckAlign		RCX, @@exit							; (out) Product
								CheckAlign		R8, @@exit							; (in) Multiplicand

				; caller might be doing multiply 'in-place', so need to save the original multiplicand, prior to clearing callers product (A = A * x), or (A *= x)
 000001B9  4C/ 8D 55 00						LEA				R10, l_Ptr.multiplicand
								Copy512			R10, R8
 000001BD  62 41 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ R8 ]
	   38
 000001C3  62 41 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ R10 ], ZMM31
	   3A

				; clear callers product and overflow
				;	Note: if caller used multiplicand and product as the same variable (memory space),
				;	this would wipe the multiplicand. Hence the saving of the multiplicand on the stack. (above)
 000001C9  48/ 33 C0						XOR				RAX, RAX
								Zero512			RCX		   							; clear callers product (multiply uses an addition with carry, so it needs to start zeroed)
 000001CC  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000001D2  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 000001D8  48/ 89 02						MOV				Q_PTR [ RDX ], RAX					; clear callers overflow
 000001DB  4C/ 8B D2		 				MOV				R10, RDX							; RDX (pointer to callers overflow) gets used in the MUL: save it in R10 (a volatile reg)

				; FOR EACH index of 7 thru 1 (omiting 0): fetch qword of multiplicand, multiply, add 128 bit result (RAX, RDX) to running working product
								FOR				idx, < 7, 6, 5, 4, 3, 2, 1 >		; Note: this is not a 'real' for statement, this is a macro that generates an unwound loop
								MOV				RAX, l_Ptr.multiplicand + [ idx * 8 ] ; multiplicand [ idx ] qword -> RAX
								TEST			RAX, RAX							; skip multiply if zero	
								JZ				@F
								MUL				R9									; times multiplier -> RAX, RDX
								ADD				Q_PTR [ RCX ] [ idx * 8 ], RAX		; add RAX to working product [ idx ] qword
								ADC				Q_PTR [ RCX ] [ (idx - 1) * 8 ], RDX ; and add RDX with carry to [ idx - 1 ] qword of working product
				@@:
								ENDM
 000001DE  48/ 8B 45 38	     1					MOV				RAX, l_Ptr.multiplicand + [ 7 * 8 ] ; multiplicand [ idx ] qword -> RAX
 000001E2  48/ 85 C0	     1					TEST			RAX, RAX							; skip multiply if zero	
 000001E5  74 0B	     1					JZ				@F
 000001E7  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 000001EA  48/ 01 41 38	     1					ADD				Q_PTR [ RCX ] [ 7 * 8 ], RAX		; add RAX to working product [ idx ] qword
 000001EE  48/ 11 51 30	     1					ADC				Q_PTR [ RCX ] [ (7 - 1) * 8 ], RDX ; and add RDX with carry to [ idx - 1 ] qword of working product
 000001F2		     1	@@:
 000001F2  48/ 8B 45 30	     1					MOV				RAX, l_Ptr.multiplicand + [ 6 * 8 ] ; multiplicand [ idx ] qword -> RAX
 000001F6  48/ 85 C0	     1					TEST			RAX, RAX							; skip multiply if zero	
 000001F9  74 0B	     1					JZ				@F
 000001FB  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 000001FE  48/ 01 41 30	     1					ADD				Q_PTR [ RCX ] [ 6 * 8 ], RAX		; add RAX to working product [ idx ] qword
 00000202  48/ 11 51 28	     1					ADC				Q_PTR [ RCX ] [ (6 - 1) * 8 ], RDX ; and add RDX with carry to [ idx - 1 ] qword of working product
 00000206		     1	@@:
 00000206  48/ 8B 45 28	     1					MOV				RAX, l_Ptr.multiplicand + [ 5 * 8 ] ; multiplicand [ idx ] qword -> RAX
 0000020A  48/ 85 C0	     1					TEST			RAX, RAX							; skip multiply if zero	
 0000020D  74 0B	     1					JZ				@F
 0000020F  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 00000212  48/ 01 41 28	     1					ADD				Q_PTR [ RCX ] [ 5 * 8 ], RAX		; add RAX to working product [ idx ] qword
 00000216  48/ 11 51 20	     1					ADC				Q_PTR [ RCX ] [ (5 - 1) * 8 ], RDX ; and add RDX with carry to [ idx - 1 ] qword of working product
 0000021A		     1	@@:
 0000021A  48/ 8B 45 20	     1					MOV				RAX, l_Ptr.multiplicand + [ 4 * 8 ] ; multiplicand [ idx ] qword -> RAX
 0000021E  48/ 85 C0	     1					TEST			RAX, RAX							; skip multiply if zero	
 00000221  74 0B	     1					JZ				@F
 00000223  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 00000226  48/ 01 41 20	     1					ADD				Q_PTR [ RCX ] [ 4 * 8 ], RAX		; add RAX to working product [ idx ] qword
 0000022A  48/ 11 51 18	     1					ADC				Q_PTR [ RCX ] [ (4 - 1) * 8 ], RDX ; and add RDX with carry to [ idx - 1 ] qword of working product
 0000022E		     1	@@:
 0000022E  48/ 8B 45 18	     1					MOV				RAX, l_Ptr.multiplicand + [ 3 * 8 ] ; multiplicand [ idx ] qword -> RAX
 00000232  48/ 85 C0	     1					TEST			RAX, RAX							; skip multiply if zero	
 00000235  74 0B	     1					JZ				@F
 00000237  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 0000023A  48/ 01 41 18	     1					ADD				Q_PTR [ RCX ] [ 3 * 8 ], RAX		; add RAX to working product [ idx ] qword
 0000023E  48/ 11 51 10	     1					ADC				Q_PTR [ RCX ] [ (3 - 1) * 8 ], RDX ; and add RDX with carry to [ idx - 1 ] qword of working product
 00000242		     1	@@:
 00000242  48/ 8B 45 10	     1					MOV				RAX, l_Ptr.multiplicand + [ 2 * 8 ] ; multiplicand [ idx ] qword -> RAX
 00000246  48/ 85 C0	     1					TEST			RAX, RAX							; skip multiply if zero	
 00000249  74 0B	     1					JZ				@F
 0000024B  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 0000024E  48/ 01 41 10	     1					ADD				Q_PTR [ RCX ] [ 2 * 8 ], RAX		; add RAX to working product [ idx ] qword
 00000252  48/ 11 51 08	     1					ADC				Q_PTR [ RCX ] [ (2 - 1) * 8 ], RDX ; and add RDX with carry to [ idx - 1 ] qword of working product
 00000256		     1	@@:
 00000256  48/ 8B 45 08	     1					MOV				RAX, l_Ptr.multiplicand + [ 1 * 8 ] ; multiplicand [ idx ] qword -> RAX
 0000025A  48/ 85 C0	     1					TEST			RAX, RAX							; skip multiply if zero	
 0000025D  74 0A	     1					JZ				@F
 0000025F  49/ F7 E1	     1					MUL				R9									; times multiplier -> RAX, RDX
 00000262  48/ 01 41 08	     1					ADD				Q_PTR [ RCX ] [ 1 * 8 ], RAX		; add RAX to working product [ idx ] qword
 00000266  48/ 11 11	     1					ADC				Q_PTR [ RCX ] [ (1 - 1) * 8 ], RDX ; and add RDX with carry to [ idx - 1 ] qword of working product
 00000269		     1	@@:

				; Most significant (idx=0), the high order result of the multiply in RDX, goes to the overflow of the caller
 00000269  48/ 8B 45 00						MOV				RAX, l_Ptr.multiplicand
 0000026D  48/ 85 C0						TEST			RAX, RAX							; skip multiply if zero
 00000270  74 0C						JZ				@@exit
 00000272  49/ F7 E1						MUL				R9
 00000275  48/ 01 01						ADD				Q_PTR [ RCX ] [ 0 * 8 ], RAX
 00000278  49/ 11 12						ADC				Q_PTR [ R10 ], RDX					; last qword overflow is also the operation overflow
 0000027B  48/ 33 C0						XOR				RAX, RAX							; return zero
 0000027E			@@exit:			Local_Exit
 0000027E  48/ 81 C4	     1					ADD				RSP,  _allocspace
	   00000100
 00000285  5D		     1					POP				RBP
 00000286  C3		     1					RET

 00000287			mult_uT64		ENDP		
 00000287			ui512_multiply	ENDS
								END													; end of module
Microsoft (R) Macro Assembler (x64) Version 14.50.35721.0   12/29/25 19:46:08
ui512_multiply.asm					     Symbols 2 - 1




Macros:

                N a m e                 Type

CheckAlign . . . . . . . . . . .	Proc
Copy512Q . . . . . . . . . . . .	Proc
Copy512  . . . . . . . . . . . .	Proc
GetZatMask . . . . . . . . . . .	Proc
Leaf_Entry . . . . . . . . . . .	Proc
Local_Exit . . . . . . . . . . .	Proc
Proc_w_Local . . . . . . . . . .	Proc
SetZatMask . . . . . . . . . . .	Proc
VerifyRegs . . . . . . . . . . .	Proc
Zero512Q . . . . . . . . . . . .	Proc
Zero512  . . . . . . . . . . . .	Proc
push_reg . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

mult64_Locals  . . . . . . . . .	 00000040
  multiplicand . . . . . . . . .	 00000000	 QWord
mult_u_Locals  . . . . . . . . .	 00000080
  product  . . . . . . . . . . .	 00000000	 QWord


Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

kMask  . . . . . . . . . . . . .	 00000009      00000009
  b8 . . . . . . . . . . . . . .	 00000008      00000001	     0100     ?
  b7 . . . . . . . . . . . . . .	 00000007      00000001	     0080     ?
  b6 . . . . . . . . . . . . . .	 00000006      00000001	     0040     ?
  b5 . . . . . . . . . . . . . .	 00000005      00000001	     0020     ?
  b4 . . . . . . . . . . . . . .	 00000004      00000001	     0010     ?
  b3 . . . . . . . . . . . . . .	 00000003      00000001	     0008     ?
  b2 . . . . . . . . . . . . . .	 00000002      00000001	     0004     ?
  b1 . . . . . . . . . . . . . .	 00000001      00000001	     0002     ?
  b0 . . . . . . . . . . . . . .	 00000000      00000001	     0001     ?


Types:

                N a m e                  Size     Attr

LPVOID . . . . . . . . . . . . .	 00000008     PTR VOID


Segments:

                N a m e                  Length   Align   Class

ui512_multiply . . . . . . . . .	 00000287 16	  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

mult_uT64  . . . . . . . . . . .	P 	 000001A0 ui512_multiply	Length= 000000E7 Public
  @@exit . . . . . . . . . . . .	L 	 0000027E ui512_multiply	
mult_u . . . . . . . . . . . . .	P 	 00000010 ui512_multiply	Length= 0000017E Public
  @@multloop . . . . . . . . . .	L 	 000000B0 ui512_multiply	
  @@nextmult . . . . . . . . . .	L 	 000000DE ui512_multiply	
  @@exit . . . . . . . . . . . .	L 	 00000126 ui512_multiply	
  @@zeroandexit  . . . . . . . .	L 	 0000013A ui512_multiply	
  @@copyandexit  . . . . . . . .	L 	 00000164 ui512_multiply	


Symbols:

                N a m e                 Type     Value    Attr

$xdatasym  . . . . . . . . . . .	Byte	 00000000 _XDATA	
B_PTR  . . . . . . . . . . . . .	Text   	 BYTE PTR
CPEQ . . . . . . . . . . . . . .	Number	 00000000h   
CPFALSE  . . . . . . . . . . . .	Number	 00000003h   
CPGE . . . . . . . . . . . . . .	Number	 00000005h   
CPGT . . . . . . . . . . . . . .	Number	 00000006h   
CPLE . . . . . . . . . . . . . .	Number	 00000002h   
CPLT . . . . . . . . . . . . . .	Number	 00000001h   
CPNE . . . . . . . . . . . . . .	Number	 00000004h   
CPTRUE . . . . . . . . . . . . .	Number	 00000007h   
D_PTR  . . . . . . . . . . . . .	Text   	 DWORD PTR
Q_PTR  . . . . . . . . . . . . .	Text   	 QWORD PTR
R8Home . . . . . . . . . . . . .	Text   	 Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 3 ) * 8 ) ) ]
R9Home . . . . . . . . . . . . .	Text   	 Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 4 ) * 8 ) ) ]
RCXHome  . . . . . . . . . . . .	Text   	 Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 1 ) * 8 ) ) ]
RDXHome  . . . . . . . . . . . .	Text   	 Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 2 ) * 8 ) ) ]
W_PTR  . . . . . . . . . . . . .	Text   	 WORD PTR
XM_PTR . . . . . . . . . . . . .	Text   	 XMMWORD PTR
YM_PTR . . . . . . . . . . . . .	Text   	 YMMWORD PTR
ZM_PTR . . . . . . . . . . . . .	Text   	 ZMMWORD PTR
__CheckAlign . . . . . . . . . .	Number	 00000000h   
__UseBMI2  . . . . . . . . . . .	Number	 00000001h   
__UseQ . . . . . . . . . . . . .	Number	 00000001h   
__UseX . . . . . . . . . . . . .	Number	 00000000h   
__UseY . . . . . . . . . . . . .	Number	 00000000h   
__UseZ . . . . . . . . . . . . .	Number	 00000001h   
__VerifyRegs . . . . . . . . . .	Number	 00000001h   
_alignspace  . . . . . . . . . .	Number	 00000040h   
_allocspace  . . . . . . . . . .	Number	 00000100h   
_localspace  . . . . . . . . . .	Number	 00000040h   
_shadowspace . . . . . . . . . .	Number	 00000040h   
add_uT64 . . . . . . . . . . . .	L 	 00000000 External
add_u_wc . . . . . . . . . . . .	L 	 00000000 External
add_u  . . . . . . . . . . . . .	L 	 00000000 External
and_u  . . . . . . . . . . . . .	L 	 00000000 External
compare_uT64 . . . . . . . . . .	L 	 00000000 External
compare_u  . . . . . . . . . . .	L 	 00000000 External
compile_time_options_INC . . . .	Text   	 1
copy_u . . . . . . . . . . . . .	L 	 00000000 External
div_uT64 . . . . . . . . . . . .	L 	 00000000 External
div_u  . . . . . . . . . . . . .	L 	 00000000 External
l_Ptr  . . . . . . . . . . . . .	Text   	 [RBP] + mult64_Locals
lsb_u  . . . . . . . . . . . . .	L 	 00000000 External
m32BCST  . . . . . . . . . . . .	Text   	 DWORD BCST
m64BCST  . . . . . . . . . . . .	Text   	 QWORD BCST
msb_u  . . . . . . . . . . . . .	L 	 00000000 External
mskAll8  . . . . . . . . . . . .	DWord	 00000000 External
mskB0  . . . . . . . . . . . . .	DWord	 00000000 External
mskB1  . . . . . . . . . . . . .	DWord	 00000000 External
mskB2  . . . . . . . . . . . . .	DWord	 00000000 External
mskB3  . . . . . . . . . . . . .	DWord	 00000000 External
mskB4  . . . . . . . . . . . . .	DWord	 00000000 External
mskB5  . . . . . . . . . . . . .	DWord	 00000000 External
mskB6  . . . . . . . . . . . . .	DWord	 00000000 External
mskB7  . . . . . . . . . . . . .	DWord	 00000000 External
nRegs  . . . . . . . . . . . . .	Number	 00000001h   
not_u  . . . . . . . . . . . . .	L 	 00000000 External
or_u . . . . . . . . . . . . . .	L 	 00000000 External
qOnes  . . . . . . . . . . . . .	QWord	 00000000 External
qZero  . . . . . . . . . . . . .	QWord	 00000000 External
reg_verify . . . . . . . . . . .	L 	 00000000 External
ret_GPFault  . . . . . . . . . .	DWord	 00000000 External
ret_neg_one  . . . . . . . . . .	DWord	 00000000 External
ret_one  . . . . . . . . . . . .	DWord	 00000000 External
ret_zero . . . . . . . . . . . .	DWord	 00000000 External
retcode_neg_one  . . . . . . . .	Number	 -00000001h   
retcode_one  . . . . . . . . . .	Number	 00000001h   
retcode_zero . . . . . . . . . .	Number	 00000000h   
set_uT64 . . . . . . . . . . . .	L 	 00000000 External
shl_u  . . . . . . . . . . . . .	L 	 00000000 External
shr_u  . . . . . . . . . . . . .	L 	 00000000 External
sub_uT64 . . . . . . . . . . . .	L 	 00000000 External
sub_u_wb . . . . . . . . . . . .	L 	 00000000 External
sub_u  . . . . . . . . . . . . .	L 	 00000000 External
ui512_externs_INC  . . . . . . .	Text   	 1
ui512_legalnotes_INC . . . . . .	Number	 00000001h   
ui512_macros_INC . . . . . . . .	Text   	 1
xor_u  . . . . . . . . . . . . .	L 	 00000000 External
zero_u . . . . . . . . . . . . .	L 	 00000000 External

	   0 Warnings
	   0 Errors
