Microsoft (R) Macro Assembler (x64) Version 14.50.35721.0   12/24/25 15:08:13
ui512_division.asm					     Page 1 - 1


				;
				;			ui512_division
				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;
				;			File:			ui512_division.asm
				;			Author:			John G. Lynch
				;			Legal:			Copyright @2025, per MIT License below
				;			Date:			November 19, 2025  (file creation)

								INCLUDE			ui512_legalnotes.inc
			      C ;
			      C ;			ui512 Legal Notes
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			File:			ui512_legalnotes.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright 2025, per MIT License included
			      C ;			Date:			Octoberr 24, 2025
			      C ;
			      C IFNDEF							ui512_legalnotes_INC
 = 00000001		      C ui512_legalnotes_INC			EQU		1
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			Notes:
			      C ;				ui512 is a small project to provide basic operations for a variable type of unsigned 512 bit integer.
			      C ;
			      C ;				ui512a provides basic operations: zero, copy, compare, add, subtract.
			      C ;				ui512b provides basic bit-oriented operations: shift left, shift right, and, or, not, least significant bit and most significant bit.
			      C ;               ui512md provides multiply and divide.
			      C ;
			      C ;				It is written in assembly language, using the MASM (ml64) assembler provided as an option within Visual Studio.
			      C ;				(currently using VS Community 2022 17.14.10)
			      C ;
			      C ;				It provides external signatures that allow linkage to C and C++ programs,
			      C ;				where a shell/wrapper could encapsulate the methods as part of an object.
			      C ;
			      C ;				Note: X64 ZMM regs are "little-endian". The 8 QWORD C array declarion is "big-endian".
			      C ;				In memory the most significant word is first: var[0], the least last var[7]. Normally not an issue,
			      C ;				but when that var is laoded in a Z-reg, the least significant is first, and the most last, which is
			      C ;				the way z-regs are loaded, but convention has the z-reg first word commonly termed the most significant, 
			      C ;				which is not the way our c arrays are defined. Not an issue programmatically, but often a qword shift left, or right
			      C ;				or a carry or borrow to the next most significant word is not the same when the data is in a z-reg.
			      C ;
			      C ;				It has assembly time options directing the use of Intel processor extensions: AVX4, AVX2, SIMD, or none:
			      C ;				(Z (512), Y (256), or X (128) registers, or regular Q (64bit)).
			      C ;
			      C ;				Note: The file "compile_time_options.inc" contains the options that can be configured for extension usage, and other options.
			      C ;
			      C ;				If processor extensions are used, the caller must align the variables declared and passed
			      C ;				on the appropriate byte boundary (e.g. alignas 64 for 512)
			      C ;
			      C ;				The modules (in total) are very light-weight (less than 10K bytes) and relatively fast,
			      C ;				but is not intended for all processor types or all environments. 
			      C ;
			      C ;				Intended use cases:
			      C ;					1.) a "sum of primes" for primes up to 2^48. 
			      C ;					2.) elliptical curve cryptography (ECC)
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			MIT License
			      C ;
			      C ;			Copyright (c) 2024 John G. Lynch
			      C ;
			      C ;				Permission is hereby granted, free of charge, to any person obtaining a copy
			      C ;				of this software and associated documentation files (the "Software"), to deal
			      C ;				in the Software without restriction, including without limitation the rights
			      C ;				to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
			      C ;				copies of the Software, and to permit persons to whom the Software is
			      C ;				furnished to do so, subject to the following conditions:
			      C ;
			      C ;				The above copyright notice and this permission notice shall be included in all
			      C ;				copies or substantial portions of the Software.
			      C ;
			      C ;				THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
			      C ;				IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
			      C ;				FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
			      C ;				AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
			      C ;				LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
			      C ;				OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
			      C ;				SOFTWARE.
			      C ;
			      C ENDIF			; ui512_legalnotes_INC
			      C 
								INCLUDE			ui512_compile_time_options.inc
			      C ;
			      C ;			ui512_compile_time_options
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			File:			ui512_compile_time_options.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2025, per MIT License included
			      C ;			Date:			August 20, 2025 (file creation)
			      C ;
			      C IFNDEF							compile_time_options_INC
 = 1			      C compile_time_options_INC		EQU			<1>
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Configuration choices
			      C ;
			      C ;	Note: Choosing these options requires knowledge of the target machine CPU model. If you are unsure of the capabiites of the target machine CPU,
			      C ;	You can use the "CPU-Z" tool. https://www.cpuid.com/downloads/cpu-z/cpu-z_2.09-en.exe 
			      C ;	Basically, Intel Skylake and later can use "Z", Haswell and later can use BMI2, etc. 
			      C ;	Too many processors, options, vendors for me to list here. Go to the CPU vendor specifications, or use the tool to inform your choice.
			      C ;
			      C ;	Note: This is intended to be a mutually exclusive choice (UseZ thru UseQ).
			      C ;	However, the coding of the options selects the "highest" one used and ignores the rest ( If __UseZ ... ELSEIF __UseY ... )
			      C 
 = 00000001		      C __UseZ			EQU				1									; Use AVX4 processor features (512 bit registers and instructions)
 = 00000000		      C __UseY			EQU				0									; Use AVX2 processor features (256 bit registers and instructions)
 = 00000000		      C __UseX			EQU				0									; Use SIMD/SSE processor features (128 bit registers and instructions)
 = 00000001		      C __UseQ			EQU				1									; Do not use extensions, use standard x64 bit registers and instructions
			      C ;
 = 00000001		      C __UseBMI2		EQU				1									; Bit manipulation instructions (Haswell and later) ref:https://en.wikipedia.org/wiki/X86_Bit_manipulation_instruction_set
			      C ;
 = 00000001		      C __VerifyRegs	EQU				1									; in debug mode, or with unit tests, define routine to verify non-volatile regs 
 = 00000000		      C __CheckAlign	EQU				0									; User is expected to pass arguments aligned on 64 byte boundaries, 
			      C ;																	; This setting enforces that with a check. It should not be necessary, but included to help debugging
			      C 
			      C ENDIF			; ui512_compile_time_options_INC
			      C 
								INCLUDE			ui512_macros.inc
			      C ;
			      C ;			ui512 Macros
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			File:			ui512_macros.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2025, per MIT License included
			      C ;			Date:			October 24, 2025  (file creation)
			      C ;
			      C IFNDEF							ui512_macros_INC
 = 1			      C ui512_macros_INC				EQU		<1>
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ; Some coding shortcuts
			      C ;
 = ZMMWORD PTR		      C ZM_PTR			EQU				ZMMWORD PTR 
 = YMMWORD PTR		      C YM_PTR			EQU				YMMWORD PTR
 = XMMWORD PTR		      C XM_PTR			EQU				XMMWORD PTR
 = QWORD PTR		      C Q_PTR			EQU				QWORD PTR
 = DWORD PTR		      C D_PTR			EQU				DWORD PTR
 = WORD PTR		      C W_PTR			EQU				WORD PTR
 = BYTE PTR		      C B_PTR			EQU				BYTE PTR
 = DWORD BCST		      C m32BCST			EQU				DWORD BCST
 = QWORD BCST		      C m64BCST			EQU				QWORD BCST
			      C LPVOID			TYPEDEF			PTR VOID
			      C 
			      C ; Mask codes (for compares using instructions like VPCMPUQ)
 = 00000000		      C CPEQ			EQU				0
 = 00000001		      C CPLT			EQU				1
 = 00000002		      C CPLE			EQU				2
 = 00000003		      C CPFALSE			EQU				3
 = 00000004		      C CPNE			EQU				4
 = 00000005		      C CPGE			EQU				5
 = 00000006		      C CPGT			EQU				6
 = 00000007		      C CPTRUE			EQU				7
			      C 
			      C ; Masks commonly used: here in Record form, which can be used as immediate values. Example: OR	R8D, MASK kMask.b8
			      C kMask			RECORD			b8:1, b7:1, b6:1, b5:1, b4:1, b3:1, b2:1, b1:1, b0:1
			      C 
			      C ; Return codes commonly used.	
 = 00000000		      C retcode_zero	EQU				0
 = 00000001		      C retcode_one		EQU				1
 =-00000001		      C retcode_neg_one	EQU				-1
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;           Notes on x64 calling conventions        specifically "fast call"
			      C ; ref: https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170
			      C ; The callers first four parameters are passed in registers: RCX, RDX, R8, R9 if integer or address; if floating point XMM0L, XMM1L, XMM2L, XMM3L
			      C ; return (if any) is in EAX
			      C ;
			      C ; RAX, RCX, RDX, R8, R9, R10, R11 are considered volatile, and do not need to be saved
			      C ; XMM0, YMM0, ZMM0 and  ..1, ..2, ..3, ..4, and ..5 are considered volatile, and do not need to be saved
			      C ; ZMM16 to ZMM31: volatile, also do not need to be zeroed to resume full clock speeds
			      C ;
			      C ; R12, R13, R14, R15, RDI, RSI, RBX, RBP, RSP are non-volatile and if used, must be restored
			      C ; XMM, YMM, and ZMM ..6 thru 15 are non-volatile and if used, must be restored
			      C ;
			      C ; A "leaf" function is one that does not call and does not change non volatile registers
			      C ; leaf functionss therefore do not need frame, prolog or epilog
			      C ;
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; Selected macros from "macamd64.inc" (c) Microsoft Corporation
			      C ;	These macros generate .xdata and .pdata entries in the executable image file.
			      C ;	The entries assist in exception and debugging; helping 'unwind' operations.
			      C ;	Only a few macros are included, and are reformatted to match coding style:;	indents and capitalization.
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; Leaf_Entry <Name>
			      C ;
			      C ; Macro Description:
			      C ;   This macro indicates the beginning of a leaf function.;
			      C ;
			      C ; Arguments:
			      C ;   Name - Supplies the name of the function
			      C ;   
			      C Leaf_Entry		MACRO			Name
			      C 				DB				6 DUP (0cch)
			      C 				ALIGN			16
			      C 				PUBLIC			Name
			      C Name			PROC
			      C ; Addresses of param regs "home" after reg pushs, and _allocspace adjust
			      C RCXHome			EQU				Q_PTR [ RSP + ( 1 * 8 ) ]	
			      C RDXHome			EQU				Q_PTR [ RSP + ( 2 * 8 ) ]
			      C R8Home			EQU				Q_PTR [ RSP + ( 3 * 8 ) ]
			      C R9Home			EQU				Q_PTR [ RSP + ( 4 * 8 ) ]
			      C 				ENDM
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; Proc_w_Local	ProcName, LocalStructName, NV_Regs_Used:vararg
			      C ;
			      C Proc_w_Local	MACRO			ProcName, LocalStructName, NV_Regs_Used:vararg
			      C 
			      C _shadowspace	EQU				40h								; stack space for caller (at top) and callee (at bottom)
			      C _localspace		=				sizeof (LocalStructName)		; space needed (on stack) for local variables
			      C _alignspace		EQU				64								; amount of space that might get truncated to get frame space aligned on specified boundary (64)
			      C _allocspace		=				_localspace + ( 2 * _shadowspace) + _alignspace	; calculate total stack space to allocate.
			      C 
			      C 				DB				6 DUP (0cch)
			      C 				ALIGN			16
			      C 				PUBLIC			ProcName						; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
			      C ProcName		PROC			FRAME
			      C 				
			      C 				MOV				[ RSP + ( 1 * 8) ], RCX
			      C 				push_reg        RBP								; standard prologue code
			      C 
			      C 	nRegs = 1
			      C 				FOR				reg, <NV_Regs_Used>				; save specified non-volatile regs on stack (in top shadowspace)
			      C 				push_reg		reg
			      C 	nRegs = nRegs + 1
			      C 				ENDM
			      C 
			      C 				SUB				RSP, _allocspace				; set stack pointer down by space needed (locals+ (2 * shadowspace))
			      C 				.ALLOCSTACK		_allocspace
			      C 	
			      C ; set frame pointer within new space, but above shadowspace
			      C 				LEA				RBP, ( _shadowspace + _alignspace ) [ RSP ]
			      C 				AND				RBP, -_alignspace				; truncate low bits of base pointer to yield aligned pointer
			      C 
			      C 				.ENDPROLOG
			      C ; Addresses of param regs "home" after reg pushs, and _allocspace adjust
			      C RCXHome			EQU				Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 1 ) * 8 ) ) ]
			      C RDXHome			EQU				Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 2 ) * 8 ) ) ] 
			      C R8Home			EQU				Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 3 ) * 8 ) ) ]
			      C R9Home			EQU				Q_PTR  [ RSP + ( _allocspace + ( ( nRegs + 4 ) * 8 ) ) ]
			      C l_Ptr			EQU				[RBP] + LocalStructName			; set up shortcut for accessing local data structure
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; Local_Exit	NV_Regs_Used:vararg
			      C ;
			      C Local_Exit		MACRO			NV_Regs_Used:vararg
			      C 				ADD				RSP,  _allocspace
			      C 				FOR				reg, <NV_Regs_Used>
			      C 				POP				reg
			      C 				ENDM 
			      C 				POP				RBP
			      C 				RET
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; push_reg	reg (non-volatile) to push
			      C ;
			      C push_reg		MACRO			reg
			      C 				PUSH			reg
			      C 				.PUSHREG		reg
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; CheckAlign <RAddr>
			      C ;
			      C ;			Test passed variable addresses for 64 byte alignment
			      C ;			Note: Better performance if this is off, but for debugging, maybe have it on
			      C ;
			      C CheckAlign		MACRO			Raddr:REQ, ExitLbl:VARARG
			      C 	IF	__CheckAlign
			      C 				TEST			Raddr, 63							; Is specified param aligned 64?
			      C 				JZ				@F									; Yes, passes test, continue
			      C 				MOV				EAX, 0C0000005h						; Windows code for General Protection Fault	
			      C 		IFNB	<ExitLbl>
			      C 				JMP				ExitLbl								; Return to caller, with GPFault code in EAX
			      C 		ELSE
			      C 				RET													; No, fault return with err code
			      C 		ENDIF
			      C @@:
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Zero a 512 bit destination, conditional assembly based on configuration parameters
			      C ;
			      C Zero512			MACRO			dest:REQ
			      C 	IF		__UseZ
			      C 				CheckAlign		dest
			      C 				VPXORQ			ZMM31, ZMM31, ZMM31
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				VPXORQ			YMM4, YMM4, YMM4
			      C 				FOR				idx, < 0, 4 >
			      C 				VMOVDQA64		YM_PTR [ dest ] [ idx * 8 ], YMM4
			      C 				ENDM
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				PXOR			XMM4, XMM4
			      C 				FOR				idx, < 0, 2, 4, 6 >
			      C 				MOVDQA			XM_PTR [ dest ] [ idx * 8 ], XMM4
			      C 				ENDM		
			      C 	ELSE
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Zero a 512 bit destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Zero512Q		MACRO			dest:REQ
			      C 				XOR				RAX, RAX
			      C 				FOR				idx,  < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Copy a 512 bit source to destination, conditional assembly based on configuration parameters
			      C ;
			      C Copy512			MACRO			dest:REQ, src:REQ
			      C 	IF		__UseZ 
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		ZMM31, ZM_PTR [ src ]
			      C 				VMOVDQA64		ZM_PTR [ dest ], ZMM31
			      C 	ELSEIF	__UseY
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				VMOVDQA64		YMM4, YM_PTR [ src + 0 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 0 * 8 ], YMM4	; alternate ymm regs in case pipeline can execute next without waiting for this.
			      C 				VMOVDQA64		YMM5, YM_PTR [ src ] [ 4 * 8 ]
			      C 				VMOVDQA64		YM_PTR [ dest ] [ 4 * 8 ], YMM5
			      C 	ELSEIF	__UseX
			      C 				CheckAlign		dest
			      C 				CheckAlign		src
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 0 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 0 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 2 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 2 * 8 ], XMM3
			      C 				MOVDQA			XMM4, XM_PTR [ src ] [ 4 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 4 * 8 ], XMM4
			      C 				MOVDQA			XMM3, XM_PTR [ src ] [ 6 * 8 ]
			      C 				MOVDQA			XM_PTR [ dest ] [ 6 * 8 ], XMM3
			      C 	ELSE
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 	ENDIF
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Copy a 512 bit source to destination, always use Q_PTR, avoids clock penalty from using SIMD
			      C ;
			      C Copy512Q		MACRO			dest:REQ, src:REQ
			      C 				FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
			      C 				MOV				RAX, Q_PTR [ src ] [ idx * 8 ]
			      C 				MOV				Q_PTR [ dest ] [ idx * 8 ], RAX
			      C 				ENDM
			      C 
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;	VerifyRegs <none>
			      C ;
			      C ;			If option is on, generate a function, callable by unit test routines, 
			      C ;				to save non-volatile registers in passed structure.
			      C ;
			      C IF	__VerifyRegs
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* regstruct)
			      C ;			reg_verify		-	copy non-volatile regs into callers struct of nine qwords) intended for unit tests to verify non-volatile regs are not changed
			      C ;			Prototype:		-	void reg_verify( uu64* regstruct);
			      C ;			regstruct		-	Address of 9 QWORDS in a struct where regs will be copied (in RCX)
			      C ; //			reg_verify		-	save non-volatile regs for verification (debug)
			      C ; //			Prototype		-	void reg_verify ( u64* reg struct)
			      C 
			      C EXTERNDEF		reg_verify:PROC	;	void reg_verify ( u64* reg struct)
			      C 
			      C VerifyRegs		MACRO
			      C 				Leaf_Entry		reg_verify
			      C 				MOV				Q_PTR [ RCX ] [ 0 * 8 ], R12
			      C 				MOV				Q_PTR [ RCX ] [ 1 * 8 ], R13
			      C 				MOV				Q_PTR [ RCX ] [ 2 * 8 ], R14
			      C 				MOV				Q_PTR [ RCX ] [ 3 * 8 ], R15
			      C 				MOV				Q_PTR [ RCX ] [ 4 * 8 ], RDI
			      C 				MOV				Q_PTR [ RCX ] [ 5 * 8 ], RSI
			      C 				MOV				Q_PTR [ RCX ] [ 6 * 8 ], RBX
			      C 				MOV				Q_PTR [ RCX ] [ 7 * 8 ], RBP
			      C 				MOV				Q_PTR [ RCX ] [ 8 * 8 ], RSP
			      C 				RET
			      C reg_verify		ENDP
			      C 				ENDM
			      C ENDIF
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Get a GP reg QWORD from within a Z register as specified by mask
			      C ;			Note: RAX, ZMM0 and k1 are used and not restored
			      C ;			Example usage: GetZatIdx R11, ZMM1, MaskBit2 or SetZatIdx ZMM1, R12, [ R9 ]  (where R9 is a bit mask, not an integer index)
			      C ;			Note: These are req to reg ops; no memory fetches (other than instructions from pipeline)
			      C ;
			      C GetZatMask		MACRO			dest, src, mask
			      C 				LEA				RAX,  mask
			      C 				KMOVB			k1, RAX
			      C 				VPCOMPRESSQ		ZMM0 {k1}{z}, src
			      C 				VMOVQ			dest, XMM0
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;			Set a GP Reg QWORD within a Z register as specified by mask
			      C ;			Note: RAX and k1 are used and not restored
			      C ;			Example usage: SetZatIdx ZMM1, R8, MaskBit2
			      C ;			Note: These are req to reg ops; no memory fetches (other than instructions from pipeline)
			      C ;
			      C SetZatMask		MACRO			dest, src, mask
			      C 				LEA				RAX, mask
			      C 				KMOVB			k1, RAX
			      C 				VPBROADCASTQ 	dest {k1}, src
			      C 				ENDM
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ENDIF			; ui512_macros_INC
			      C 
								INCLUDE			ui512_externs.inc
			      C ;
			      C ;			ui512 Externs
			      C ;
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;
			      C ;			File:			ui512_externs.inc
			      C ;			Author:			John G. Lynch
			      C ;			Legal:			Copyright @2025, per MIT License included
			      C ;			Date:			October 24, 2025
			      C ;
			      C IFNDEF							ui512_externs_INC
 = 1			      C ui512_externs_INC				EQU		<1>
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ;   header file equivalent extern declarations
			      C ;			EXTERN "C" signatures 
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_clear_copy_set.asm:
			      C ;
			      C ;	// void zero_u ( u64* destarr ); 
			      C ;	// fill supplied 512bit (8 QWORDS) with zero
			      C EXTERNDEF		zero_u:PROC
			      C 
			      C ;	// void copy_u ( u64* destarr, u64* srcarr );
			      C ;	// copy supplied 512bit (8 QWORDS) source to supplied destination
			      C EXTERNDEF		copy_u:PROC
			      C 
			      C ;	// void set_uT64 ( u64* destarr, u64 value );
			      C ;	// set supplied destination 512 bit to supplied u64 value
			      C EXTERNDEF		set_uT64:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_compare.asm
			      C ;
			      C ;	// s16 compare_u ( u64* lh_op, u64* rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied RH operand
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_u:PROC
			      C 
			      C ;	// s16 compare_uT64 ( u64* lh_op, u64 rh_op );
			      C ;	// compare supplied 512bit (8 QWORDS) LH operand to supplied 64bit RH operand (value)
			      C ;	// returns: (0) for equal, -1 for less than, 1 for greater than (logical, unsigned compare)
			      C EXTERNDEF		compare_uT64:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_addition.asm
			      C ;
			      C ;	// s16 add_u ( u64* sum, u64* addend1, u64* addend2 );
			      C ;	// add supplied 512bit (8 QWORDS) sources, place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_u:PROC
			      C 
			      C ;	// s16 add_u_wc ( u64* sum, u64* addend1, u64* addend2, s16 carry );
			      C ;	// add supplied 512bit (8 QWORDS) sources, with passed-in carry, place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_u_wc:PROC
			      C 
			      C ;	// s16 add_uT64 ( u64* sum, u64* addend1, u64 addend2 );
			      C ;	// add 64bit QWORD (value) to supplied 512bit (8 QWORDS), place in supplied destination
			      C ;	// returns: zero for no carry, 1 for carry (overflow)
			      C EXTERNDEF		add_uT64:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_subtraction.asm
			      C ;
			      C ;	// s16 sub_u ( u64* difference, u64* left operand, u64* right operand );
			      C ;	// subtract supplied 512bit (8 QWORDS) RH OP from LH OP giving difference in destination
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_u:PROC
			      C 
			      C ;	// s16 sub_u_wc ( u64* difference, u64* left operand, u64* right operand, s16 borrow );
			      C ;	// subtract supplied 512bit (8 QWORDS) RH OP from LH OP, with passed-in borrow giving difference in destination
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_u_wb:PROC
			      C 
			      C ;	// s16 sub_uT64( u64* difference, u64* left operand, u64 right operand );
			      C ;	// subtract supplied 64 bit right hand (64 bit value) op from left hand (512 bit) giving difference
			      C ;	// returns: zero for no borrow, 1 for borrow (underflow)
			      C EXTERNDEF		sub_uT64:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_multiply.asm
			      C ;
			      C ; //			mult_uT64		-	multiply 512 bit multiplicand by 64 bit multiplier, giving 512 product, 64 bit overflow
			      C ; //			Prototype:		-	s16 mult_uT64( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
			      C EXTERNDEF		mult_uT64:PROC	;	s16 mult_uT64( u64* product, u64* overflow, u64* multiplicand, u64 multiplier);
			      C 
			      C ; //			mult_u			-	multiply 512 multiplicand by 512 multiplier, giving 512 product, overflow
			      C ; //			Prototype:		-	s16 mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier);
			      C EXTERNDEF		mult_u:PROC		;	s16 mult_u( u64* product, u64* overflow, u64* multiplicand, u64* multiplier);
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_division.asm
			      C ;
			      C ; //			div_uT64		-	divide 512 bit dividend by 64 bit bit divisor, giving 512 bit quotient and 64 bit remainder
			      C ; //			Prototype:		-	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64 divisor,);
			      C EXTERNDEF		div_uT64:PROC	;	s16 div_uT64( u64* quotient, u64* remainder, u64* dividend, u64 divisor);
			      C 
			      C ; //			div_u			-	divide 512 bit dividend by 512 bit divisor, giving 512 bit quotient and remainder
			      C ; //			Prototype:		-	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor);
			      C EXTERNDEF		div_u:PROC		;	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor);
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_significance.asm
			      C 
			      C ;   // find most significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 msb_u( u64* );
			      C ;   // returns: -1 if no most significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C ;	//	Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit).
			      C ;	//			a returned 511 means bit63 of the first word; (the left most bit).	
			      C EXTERNDEF		msb_u:PROC
			      C 
			      C ;   // find least significant bit in supplied source 512bit (8 QWORDS)
			      C ;	// s16 lsb_u( u64* );
			      C ;   // returns: -1 if no least significant bit, bit number otherwise, bits numbered 0 to 511 inclusive
			      C ;	//	Note:	a returned zero means the significant bit is bit0 of the eighth word of the 512bit source parameter; (the right most bit).
			      C ;	//			a returned 511 means bit63 of the first word; (the left most bit).	
			      C EXTERNDEF		lsb_u:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_shift.asm
			      C ;
			      C ;   // void shr_u ( u64* destination, u64* source, u16 bits_to_shift )
			      C ;   // shift supplied source 512bit (8 QWORDS) right, put in destination
			      C EXTERNDEF		shr_u:PROC
			      C 
			      C ;   // void shl_u ( u64* destination, u64* source, u16 bits_to_shift );
			      C ;   // shift supplied source 512bit (8 QWORDS) left, put in destination
			      C EXTERNDEF		shl_u:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_bitops
			      C ;
			      C ;   // void and_u ( u64* destination, u64* lh_op, u64* rh_op );
			      C ;   // logical 'AND' bits in lh_op, rh_op, put result in destination
			      C EXTERNDEF		and_u:PROC
			      C 
			      C ;   // logical 'OR' bits in lh_op, rh_op, put result in destination
			      C ;   // void or_u( u64* destination, u64* lh_op, u64* rh_op);
			      C EXTERNDEF		or_u:PROC
			      C 
			      C ;   // logical 'XOR' bits in lh_op, rh_op, put result in destination
			      C ;   // void xor_u( u64* destination, u64* lh_op, u64* rh_op);
			      C EXTERNDEF		xor_u:PROC
			      C 
			      C ;   // logical 'NOT' bits in source, put result in destination
			      C ;	// void not_u( u64* destination, u64* source);
			      C EXTERNDEF		not_u:PROC
			      C 
			      C ;--------------------------------------------------------------------------------------------------------------------------------------------------------------
			      C ; from ui512_global_data
			      C ;
			      C EXTERNDEF		qOnes:QWORD
			      C EXTERNDEF		qZero:QWORD
			      C 
			      C EXTERNDEF		ret_zero:DWORD
			      C EXTERNDEF		ret_one:DWORD
			      C EXTERNDEF		ret_neg_one:DWORD
			      C EXTERNDEF		ret_GPFault:DWORD
			      C 
			      C EXTERNDEF		mskB0:DB
			      C EXTERNDEF		mskB1:DB
			      C EXTERNDEF		mskB2:DB
			      C EXTERNDEF		mskB3:DB
			      C EXTERNDEF		mskB4:DB
			      C EXTERNDEF		mskB5:DB
			      C EXTERNDEF		mskB6:DB
			      C EXTERNDEF		mskB7:DB
			      C EXTERNDEF		mskAll8:DB
			      C 
			      C ENDIF			; ui512_externs_INC
			      C 
			      C 
				.NOLISTIF
								OPTION			CASEMAP:NONE
 00000000			ui512_division	SEGMENT			PARA 'CODE'

				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			EXTERNDEF		div_u:PROC					; s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor)
				;			div_u			-	divide 512 bit dividend by 512 bit divisor, giving 512 bit quotient and remainder
				;			Prototype:		-	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64* divisor);
				;			quotient		-	Address of 8 QWORDS to store resulting quotient (in RCX)
				;			remainder		-	Address of 8 QWORDs for resulting remainder (in RDX)
				;			dividend		-	Address of 8 QWORDS dividend (in R8)
				;			divisor			-	Address of 8 QWORDs divisor (in R9)
				;			returns			-	0 for success, -1 for attempt to divide by zero, (GP_Fault) for mis-aligned parameter address

 000001C0			div_u_Locals	STRUCT

 00000000  00000010 [		currnumerator	QWORD			16 dup (?)							; scratch working copy of dividend (numerator)
	    0000000000000000
	   ]
 00000080  00000010 [		qdiv			QWORD			16 dup (?)							; scratch working copy of (trial) qhat * divisor
	    0000000000000000
	   ]
 00000100  00000008 [		quotient		QWORD			8 dup (?)							; working copy of quotient
	    0000000000000000
	   ]
 00000140  00000008 [		normdivisor		QWORD			8 dup (?)							; working copy of normalized divisor
	    0000000000000000
	   ]
 00000180  0000000000000000	qHat			QWORD			?
 00000188  0000000000000000	rHat			QWORD			?									; trial quotient and remainder
 00000190  0000000000000000	nDiv			QWORD			?									; first qword of normalized divisor
 00000198  0000000000000000	addbackRDX		QWORD			?
 000001A0  0000000000000000	addbackR11		QWORD			?									; saved pointers for add-back step
 000001A8  0000			mIdx			WORD			?
 000001AA  0000			mMSB			WORD			?
 000001AC  0000			mDim			WORD			?									; indexes and dimensions of dividend (numerator) Note: dimensions are zero-based (0 to 7)										
 000001AE  0000			nIdx			WORD			?
 000001B0  0000			nMSB			WORD			?
 000001B2  0000			nDim			WORD			?									; indexes and dimensions of divisor (denominator)
 000001B4  0000			jIdx			WORD			?
 000001B6  0000			jDim			WORD			?									; loop index and dimension of dividend (numerator) 
 000001B8  0000			normf			WORD			?
 000001BA  0000			sublen			WORD			?									; Nr bits to shift for normalization, length of subtraction
 000001BC  00000002 [						WORD			2 dup (?)							; to get back to 16 byte align for stack alloc (adjust as necessary)
	    0000
	   ]
				div_u_Locals	ENDS

				; Declare proc, save regs, set up frame
								Proc_w_Local	div_u, div_u_Locals, R12
 = 00000040		     1	_shadowspace	EQU				40h								; stack space for caller (at top) and callee (at bottom)
 = 00000040		     1	_alignspace		EQU				64								; amount of space that might get truncated to get frame space aligned on specified boundary (64)
 00000000  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 00000010		     1	div_u		PROC			FRAME
 00000010  48/ 89 4C 24	     1					MOV				[ RSP + ( 1 * 8) ], RCX
	   08
 00000015  55		     2					PUSH			RBP
 00000016  41/ 54	     3					PUSH			R12
 00000018  48/ 81 EC	     1					SUB				RSP, _allocspace				; set stack pointer down by space needed (locals+ (2 * shadowspace))
	   00000280
 0000001F  48/ 8D AC 24	     1					LEA				RBP, ( _shadowspace + _alignspace ) [ RSP ]
	   00000080
 00000027  48/ 83 E5 C0	     1					AND				RBP, -_alignspace				; truncate low bits of base pointer to yield aligned pointer
 0000002B  48/ 89 8C 24						MOV				RCXHome, RCX
	   00000298
 00000033  48/ 89 94 24						MOV				RDXHome, RDX
	   000002A0
 0000003B  4C/ 89 84 24						MOV				R8Home, R8
	   000002A8
 00000043  4C/ 89 8C 24						MOV				R9Home, R9
	   000002B0

								CheckAlign		RCX, @ret							; (out) Quotient
								CheckAlign		RDX, @ret							; (out) Remainder
								CheckAlign		R8, @ret							; (in) Dividend
								CheckAlign		R9, @ret							; (in) Divisor

 0000004B  49/ 87 FA						XCHG			RDI, R10
 0000004E  48/ 33 C0						XOR				RAX, RAX
 00000051  48/ 8D 7D 00						LEA				RDI, l_Ptr.currnumerator
 00000055  B9 000001C0						MOV				ECX, sizeof(div_u_Locals)
 0000005A  F3/ AA						REP				STOSB
 0000005C  49/ 87 FA						XCHG			RDI, R10
 0000005F  48/ 8B 8C 24						MOV				RCX, RCXHome
	   00000298
				; Initialize; in frame / stack reserved memory, clear 16 qword area for working version of quotient; set up indexes for loop
								
								Zero512			RCX									; zero callers quotient
 00000067  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 0000006D  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
								Zero512			RDX									; zero callers remainder
 00000073  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000079  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RDX ], ZMM31
	   3A
					IF __UseQ
 0000007F  62 01 85 40/ EF					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000085  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR l_Ptr.quotient, ZMM31
	   7D 04
 0000008C  62 61 FD 48/ 7F					VMOVDQA64		ZM_PTR l_Ptr.quotient + [ 8 * 8 ], ZMM31
	   7D 05
					ELSE
					ENDIF

				; Examine divisor
 00000093  49/ 8B C9						MOV				RCX, R9								; divisor
 00000096  E8 00000000 E					CALL			msb_u								; get most significant bit
 0000009B  66| 85 C0						TEST			AX, AX								; msb < 0? 
 0000009E  0F 8C 000001AD					JL				divbyzero							; divisor is zero, abort
 000000A4  0F 84 000001B3					JE				divbyone							; divisor is one, exit with remainder = 0, quotient = dividend 
 000000AA  66| 83 F8 40						CMP				AX, 64								; divisor only one 64-bit word?
 000000AE  7D 49						JGE				mbynDiv								; no, do divide of m digit by n digit

				; Divide of m 64-bit qwords by one 64 bit qword divisor, use the quicker divide routine (div_uT64), and return
 000000B0  48/ 8B 8C 24						MOV				RCX, RCXHome						; set up parms for call to div by 64bit: RCX - addr of quotient
	   00000298
 000000B8  48/ 8B 94 24						MOV				RDX, RDXHome						; RDX - addr of remainder
	   000002A0
 000000C0  4C/ 8B 84 24						MOV				R8, R8Home							; R8 - addr of dividend
	   000002A8
 000000C8  48/ 8B 84 24						MOV				RAX, R9Home
	   000002B0
 000000D0  4C/ 8B 48 38						MOV				R9, Q_PTR [ RAX ] [ 7 * 8 ]			; R9 - value of 64 bit divisor
 000000D4  E8 000001E7						CALL			div_uT64
 000000D9  48/ 8B 94 24						MOV				RDX, RDXHome						; move 64 bit remainder to last word of 8 word remainder
	   000002A0
 000000E1  48/ 8B 0A						MOV				RCX, Q_PTR [ RDX ]					; get the one qword remainder
								Zero512			RDX									; clear the 8 qword callers remainder
 000000E4  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 000000EA  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RDX ], ZMM31
	   3A
 000000F0  48/ 89 4A 38						MOV				Q_PTR [ RDX ] [ 7 * 8 ], RCX		; put the one qword remainder in the least significant qword of the callers remainder
 000000F4  E9 00000149						JMP				cleanupret							; exit normally

				; Divide m digit by n digit
 000000F9			mbynDiv:
 000000F9  66| 89 85						MOV				l_Ptr.nMSB, AX						; save msb of divisor
	   000001B0
 00000100  66| C1 E8 06						SHR				AX, 6								;
 00000104  66| 89 85						MOV				l_Ptr.nDim, AX						; Dimension (Nr Qwords) of divisor (n)
	   000001B2
 0000010B  49/ 8B C8						MOV				RCX, R8
 0000010E  E8 00000000 E					CALL			msb_u								; get msb of dividend
 00000113  66| 85 C0						TEST			AX, AX
 00000116  0F 8C 00000173					JL				numtoremain							; dividend == zero > answer is zero with remainder
 0000011C  66| 3B 85						CMP				AX, l_Ptr.nMSB						; msb of dividend < msb of divisor? -> answer is zero with dividend going to remainder
	   000001B0
 00000123  0F 8C 00000166					JL				numtoremain							;
 00000129  66| 89 85						MOV				l_Ptr.mMSB, AX						; save msb of dividend
	   000001AA
 00000130  66| C1 E8 06						SHR				AX, 6
 00000134  66| 89 85						MOV				l_Ptr.mDim, AX						; save dimension (Nr Qwords) of dividend (m)
	   000001AC

				; Normalize divisor 
 0000013B  66| 44/ 8B 85					MOV				R8W, l_Ptr.nMSB						; get msb of divisor
	   000001B0
 00000143  66| 41/ F7 D0					NOT				R8W									; complement
 00000147  66| 41/ 83 E0					AND				R8W, 63								; get bits to shift (max 63)
	   3F
 0000014C  66| 44/ 89 85					MOV				l_Ptr.normf, R8W					; save normalization factor	
	   000001B8
 00000154  48/ 8D 8D						LEA				RCX, l_Ptr.normdivisor				; put normalized divisor here
	   00000140
 0000015B  48/ 8B 94 24						MOV				RDX, R9Home							; using callers divisor
	   000002B0
 00000163  E8 00000000 E					CALL			shl_u								; shifting left until msb is in high bit position

				; Normalize dividend
 00000168  48/ 8D 4D 40						LEA				RCX, l_Ptr.currnumerator [ 8 * 8 ]	; put normalized dividend here
 0000016C  48/ 8B 94 24						MOV				RDX, R8Home							; using callers dividend
	   000002A8
 00000174  66| 44/ 8B 85					MOV				R8W, l_Ptr.normf					; get normalization factor
	   000001B8
 0000017C  E8 00000000 E					CALL			shl_u								; shifting left until msb is in high bit position

				; Check: did we shift  out msb bits of dividend?
 00000181  66| 8B 85						MOV				AX, l_Ptr.mMSB						; get msb of dividend
	   000001AA
 00000188  66| 41/ 03 C0					ADD				AX, R8W								; add in shift count
 0000018C  66| 3D 01FF						CMP				AX, 511								; did we shift out bits?
 00000190  7E 2A						JLE				normdivdone							; no
 00000192  66| FF 85						INC				l_Ptr.mDim							; yes, increment dimension of dividend
	   000001AC
 00000199  66| 83 BD						CMP				l_Ptr.mDim, 8						; did we overflow dimension?
	   000001AC 08
 000001A1  7E 19						JLE				normdivdone							; no
 000001A3  66| 44/ 8B 85					MOV				R8W, l_Ptr.nMSB
	   000001B0
 000001AB  48/ 8D 4D 00						LEA				RCX, l_Ptr.currnumerator [ 0 * 8 ]	;
 000001AF  48/ 8B 94 24						MOV				RDX, R8Home							; using callers dividend
	   000002A8
 000001B7  E8 00000000 E					Call			shl_u								; left to get shifted out bits Note: we shift entire 512 bits - msb
																					; putting low into new msb ninth word of currnumerator	
 000001BC			normdivdone:
				; Main divide loop: for j = mDim - nDim downto 0
 000001BC  66| 44/ 8B 9D					MOV				R11W, l_Ptr.mDim
	   000001AC
 000001C4  66| 44/ 2B 9D					SUB				R11W, l_Ptr.nDim
	   000001B2
 000001CC  66| 44/ 89 9D					MOV				l_Ptr.jDim, R11W					; jDim = mDim - nDim
	   000001B6
 000001D4  66| 44/ 89 9D					MOV				l_Ptr.jIdx, R11W					; jIdx = jDim
	   000001B4
 000001DC			maindivloop:
 000001DC  66| 44/ 8B 9D					MOV				R11W, l_Ptr.jDim					; jIdx = jDim
	   000001B6
 000001E4  66| 44/ 89 9D					MOV				l_Ptr.jIdx, R11W
	   000001B4
 000001EC  E8 00000069						CALL			compute_qhat						; compute qHat and rHat
 000001F1  E8 00000065						CALL			multiply_and_subtract				; multiply qHat * divisor, subtract from currnumerator
 000001F6  E8 00000061						CALL			check_and_addback					; check if we need to add back

 000001FB  66| FF 8D						DEC				l_Ptr.jDim							; jDim --
	   000001B6
 00000202  66| 83 BD						CMP				l_Ptr.jDim, 0
	   000001B6 00
 0000020A  7D D0						JGE				maindivloop							; loop until jDim < 0
				; Store quotient
 0000020C  4C/ 8D 9D						LEA				R11, l_Ptr.quotient
	   00000100
 00000213  4D/ 33 C0						XOR				R8, R8		
 00000216  66| 44/ 8B 85					MOV				R8W, l_Ptr.jIdx
	   000001B4
 0000021E  48/ 8B 85						MOV				RAX, l_Ptr.qHat
	   00000180
 00000225  4B/ 89 04 C3						MOV				 Q_PTR [ R11 ] [ R8 * 8 ], RAX		; store qHat in quotient working copy

				; Unnormalize remainder
 00000229  48/ 8D 8C 24						LEA				RCX, RDXHome						; put remainder at callers remainder
	   000002A0
 00000231  48/ 8D 55 00						LEA				RDX, l_Ptr.currnumerator			; using working copy of currnumerator
 00000235  66| 44/ 8B 85					MOV				R8W, l_Ptr.normf					; get normalization factor
	   000001B8
 0000023D  E8 00000000 E					CALL			shr_u								; shifting right to unnormalize

				; Normal exit
 00000242			cleanupret:
 00000242  48/ 33 C0						XOR				RAX, RAX							; return zero

				; Either fall-thru normal exit, or from exception handling
 00000245			cleanupwretcode:			
								Local_Exit		R12
 00000245  48/ 81 C4	     1					ADD				RSP,  _allocspace
	   00000280
 0000024C  41/ 5C	     2					POP				R12
 0000024E  5D		     1					POP				RBP
 0000024F  C3		     1					RET
				; Flat exit if exception found before frame setup, or fall thru normal exit
 00000250			@ret:
 00000250  C3							RET

				; Exception handling, divide by zero
 00000251			divbyzero:
 00000251  8D 04 25						LEA				EAX, [ retcode_neg_one ]
	   FFFFFFFF
 00000258  EB EB						JMP				cleanupwretcode

 0000025A			compute_qhat:
								; TO DO: implement compute qhat routine
 0000025A  C3							RET
 0000025B			multiply_and_subtract:
								; TO DO: implement multiply and subtract routine
 0000025B  C3							RET
 0000025C			check_and_addback:
								; TO DO: implement check and add-back routine
 0000025C  C3							RET
				; Exception handling, divide by one
 0000025D			divbyone:
 0000025D  48/ 8B 8C 24						MOV				RCX, RCXHome						; callers quotient
	   00000298
 00000265  4C/ 8B 84 24						MOV				R8,  R8Home							; callers dividend
	   000002A8
								Copy512			RCX, R8								; copy dividend to quotient
 0000026D  62 41 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ R8 ]
	   38
 00000273  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 00000279  48/ 8B 94 24						MOV				RDX, RDXHome						; callers remainder	
	   000002A0
								Zero512			RDX									; remainder is zero
 00000281  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 00000287  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RDX ], ZMM31
	   3A
 0000028D  EB B3						JMP				cleanupret

				; Exception handling, If dimension of numerator (m) is less than dimension of denominator (n), result is zero, remainder is numerator
 0000028F			numtoremain:
 0000028F  4C/ 8B 84 24						MOV				R8, R8Home							; callers dividend
	   000002A8
 00000297  48/ 8B 94 24						MOV				RDX, RDXHome						; callers remainder
	   000002A0
								Copy512			RDX, R8
 0000029F  62 41 FD 48/ 6F   1					VMOVDQA64		ZMM31, ZM_PTR [ R8 ]
	   38
 000002A5  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RDX ], ZMM31
	   3A
 000002AB  EB 95						JMP				cleanupret

 000002AD			div_u			ENDP

				;
				;--------------------------------------------------------------------------------------------------------------------------------------------------------------
				;			EXTERNDEF		div_uT64:PROC				; s16 div_uT64( u64* quotient, u64* remainder, u64* dividend, u64 divisor)
				;			div_uT64		-	divide 512 bit dividend by 64 bit divisor, giving 512 bit quotient and 64 bit remainder
				;			Prototype:		-	s16 div_u( u64* quotient, u64* remainder, u64* dividend, u64 divisor);
				;			quotient		-	Address of 8 QWORDS to store resulting quotient (in RCX)
				;			remainder		-	Address of QWORD for resulting remainder (in RDX)
				;			dividend		-	Address of 8 QWORDS dividend (in R8)
				;			divisor			-	Value of 64 bit divisor (in R9)
				;			returns			-	0 for success, -1 for attempt to divide by zero, (GP_Fault) for mis-aligned parameter address
				;
				;			Regs with contents destroyed, not restored: RAX, RDX, R10 (each considered volitile, but caller might optimize on other regs)

								Leaf_Entry		div_uT64							; Declare code section, public proc, no prolog, no frame, exceptions handled by caller
 000002AD  00000006 [	     1					DB				6 DUP (0cch)
	    CC
	   ]
 000002C0		     1	div_uT64			PROC
								CheckAlign		RCX									; (out) Quotient
								CheckAlign		R8									; (in) Dividend

				; Test divisor for divide by zero				
 000002C0  4D/ 85 C9						TEST			R9, R9
 000002C3  74 63						JZ				@@DivByZero

				; DIV instruction (64-bit) uses RAX and RDX. Need to move RDX (addr of remainder) out of the way; start it off with zero
 000002C5  4C/ 8B D2						MOV				R10, RDX							; save addr of callers remainder
 000002C8  48/ 33 D2						XOR				RDX, RDX

				; FOR EACH index of 0 thru 7: get qword of dividend, divide by divisor, store qword of quotient
								FOR				idx, < 0, 1, 2, 3, 4, 5, 6, 7 >
								MOV				RAX, Q_PTR [ R8 ] [ idx * 8 ]		; dividend [ idx ] -> RAX
								DIV				R9									; divide by divisor in R9 (as passed)
								MOV				Q_PTR [ RCX ] [ idx * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
								ENDM
 000002CB  49/ 8B 00	     1					MOV				RAX, Q_PTR [ R8 ] [ 0 * 8 ]		; dividend [ idx ] -> RAX
 000002CE  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 000002D1  48/ 89 01	     1					MOV				Q_PTR [ RCX ] [ 0 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 000002D4  49/ 8B 40 08	     1					MOV				RAX, Q_PTR [ R8 ] [ 1 * 8 ]		; dividend [ idx ] -> RAX
 000002D8  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 000002DB  48/ 89 41 08	     1					MOV				Q_PTR [ RCX ] [ 1 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 000002DF  49/ 8B 40 10	     1					MOV				RAX, Q_PTR [ R8 ] [ 2 * 8 ]		; dividend [ idx ] -> RAX
 000002E3  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 000002E6  48/ 89 41 10	     1					MOV				Q_PTR [ RCX ] [ 2 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 000002EA  49/ 8B 40 18	     1					MOV				RAX, Q_PTR [ R8 ] [ 3 * 8 ]		; dividend [ idx ] -> RAX
 000002EE  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 000002F1  48/ 89 41 18	     1					MOV				Q_PTR [ RCX ] [ 3 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 000002F5  49/ 8B 40 20	     1					MOV				RAX, Q_PTR [ R8 ] [ 4 * 8 ]		; dividend [ idx ] -> RAX
 000002F9  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 000002FC  48/ 89 41 20	     1					MOV				Q_PTR [ RCX ] [ 4 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 00000300  49/ 8B 40 28	     1					MOV				RAX, Q_PTR [ R8 ] [ 5 * 8 ]		; dividend [ idx ] -> RAX
 00000304  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 00000307  48/ 89 41 28	     1					MOV				Q_PTR [ RCX ] [ 5 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 0000030B  49/ 8B 40 30	     1					MOV				RAX, Q_PTR [ R8 ] [ 6 * 8 ]		; dividend [ idx ] -> RAX
 0000030F  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 00000312  48/ 89 41 30	     1					MOV				Q_PTR [ RCX ] [ 6 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide
 00000316  49/ 8B 40 38	     1					MOV				RAX, Q_PTR [ R8 ] [ 7 * 8 ]		; dividend [ idx ] -> RAX
 0000031A  49/ F7 F1	     1					DIV				R9									; divide by divisor in R9 (as passed)
 0000031D  48/ 89 41 38	     1					MOV				Q_PTR [ RCX ] [ 7 * 8 ], RAX		; quotient [ idx ] <- RAX ; Note: remainder in RDX for next divide

				; Last (least significant qword) divide leaves a remainder, store it at callers remainder
 00000321  49/ 89 12						MOV				Q_PTR [ R10 ], RDX					; remainder to callers remainder
 00000324  48/ 33 C0						XOR				RAX, RAX							; return zero
 00000327			@@exit:			
 00000327  C3							RET

				; Exception handling, divide by zero
 00000328			@@DivByZero:
								Zero512			RCX									; Divide by Zero. Could throw fault, but returning zero quotient, zero remainder
 00000328  62 01 85 40/ EF   1					VPXORQ			ZMM31, ZMM31, ZMM31
	   FF
 0000032E  62 61 FD 48/ 7F   1					VMOVDQA64		ZM_PTR [ RCX ], ZMM31
	   39
 00000334  48/ 33 C0						XOR				RAX, RAX
 00000337  49/ 89 02						MOV				Q_PTR [ R10 ] , RAX
 0000033A  8D 04 25						LEA				EAX, [ retcode_neg_one ]			; return error (div by zero)
	   FFFFFFFF
 00000341  EB E4						JMP				@@exit

 00000343			div_uT64		ENDP

 00000343			ui512_division	ENDS												; end of section

								END													; end of module
Microsoft (R) Macro Assembler (x64) Version 14.50.35721.0   12/24/25 15:08:13
ui512_division.asm					     Symbols 2 - 1




Macros:

                N a m e                 Type

CheckAlign . . . . . . . . . . .	Proc
Copy512Q . . . . . . . . . . . .	Proc
Copy512  . . . . . . . . . . . .	Proc
GetZatMask . . . . . . . . . . .	Proc
Leaf_Entry . . . . . . . . . . .	Proc
Local_Exit . . . . . . . . . . .	Proc
Proc_w_Local . . . . . . . . . .	Proc
SetZatMask . . . . . . . . . . .	Proc
VerifyRegs . . . . . . . . . . .	Proc
Zero512Q . . . . . . . . . . . .	Proc
Zero512  . . . . . . . . . . . .	Proc
push_reg . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

div_u_Locals . . . . . . . . . .	 000001C0
  currnumerator  . . . . . . . .	 00000000	 QWord
  qdiv . . . . . . . . . . . . .	 00000080	 QWord
  quotient . . . . . . . . . . .	 00000100	 QWord
  normdivisor  . . . . . . . . .	 00000140	 QWord
  qHat . . . . . . . . . . . . .	 00000180	 QWord
  rHat . . . . . . . . . . . . .	 00000188	 QWord
  nDiv . . . . . . . . . . . . .	 00000190	 QWord
  addbackRDX . . . . . . . . . .	 00000198	 QWord
  addbackR11 . . . . . . . . . .	 000001A0	 QWord
  mIdx . . . . . . . . . . . . .	 000001A8	 Word
  mMSB . . . . . . . . . . . . .	 000001AA	 Word
  mDim . . . . . . . . . . . . .	 000001AC	 Word
  nIdx . . . . . . . . . . . . .	 000001AE	 Word
  nMSB . . . . . . . . . . . . .	 000001B0	 Word
  nDim . . . . . . . . . . . . .	 000001B2	 Word
  jIdx . . . . . . . . . . . . .	 000001B4	 Word
  jDim . . . . . . . . . . . . .	 000001B6	 Word
  normf  . . . . . . . . . . . .	 000001B8	 Word
  sublen . . . . . . . . . . . .	 000001BA	 Word


Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

kMask  . . . . . . . . . . . . .	 00000009      00000009
  b8 . . . . . . . . . . . . . .	 00000008      00000001	     0100     ?
  b7 . . . . . . . . . . . . . .	 00000007      00000001	     0080     ?
  b6 . . . . . . . . . . . . . .	 00000006      00000001	     0040     ?
  b5 . . . . . . . . . . . . . .	 00000005      00000001	     0020     ?
  b4 . . . . . . . . . . . . . .	 00000004      00000001	     0010     ?
  b3 . . . . . . . . . . . . . .	 00000003      00000001	     0008     ?
  b2 . . . . . . . . . . . . . .	 00000002      00000001	     0004     ?
  b1 . . . . . . . . . . . . . .	 00000001      00000001	     0002     ?
  b0 . . . . . . . . . . . . . .	 00000000      00000001	     0001     ?


Types:

                N a m e                  Size     Attr

LPVOID . . . . . . . . . . . . .	 00000008     PTR VOID


Segments:

                N a m e                  Length   Align   Class

ui512_division . . . . . . . . .	 00000343 16	  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

div_uT64 . . . . . . . . . . . .	P 	 000002C0 ui512_division	Length= 00000083 Public
  @@exit . . . . . . . . . . . .	L 	 00000327 ui512_division	
  @@DivByZero  . . . . . . . . .	L 	 00000328 ui512_division	
div_u  . . . . . . . . . . . . .	P 	 00000010 ui512_division	Length= 0000029D Public
  mbynDiv  . . . . . . . . . . .	L 	 000000F9 ui512_division	
  normdivdone  . . . . . . . . .	L 	 000001BC ui512_division	
  maindivloop  . . . . . . . . .	L 	 000001DC ui512_division	
  cleanupret . . . . . . . . . .	L 	 00000242 ui512_division	
  cleanupwretcode  . . . . . . .	L 	 00000245 ui512_division	
  @ret . . . . . . . . . . . . .	L 	 00000250 ui512_division	
  divbyzero  . . . . . . . . . .	L 	 00000251 ui512_division	
  compute_qhat . . . . . . . . .	L 	 0000025A ui512_division	
  multiply_and_subtract  . . . .	L 	 0000025B ui512_division	
  check_and_addback  . . . . . .	L 	 0000025C ui512_division	
  divbyone . . . . . . . . . . .	L 	 0000025D ui512_division	
  numtoremain  . . . . . . . . .	L 	 0000028F ui512_division	


Symbols:

                N a m e                 Type     Value    Attr

$xdatasym  . . . . . . . . . . .	Byte	 00000000 _XDATA	
B_PTR  . . . . . . . . . . . . .	Text   	 BYTE PTR
CPEQ . . . . . . . . . . . . . .	Number	 00000000h   
CPFALSE  . . . . . . . . . . . .	Number	 00000003h   
CPGE . . . . . . . . . . . . . .	Number	 00000005h   
CPGT . . . . . . . . . . . . . .	Number	 00000006h   
CPLE . . . . . . . . . . . . . .	Number	 00000002h   
CPLT . . . . . . . . . . . . . .	Number	 00000001h   
CPNE . . . . . . . . . . . . . .	Number	 00000004h   
CPTRUE . . . . . . . . . . . . .	Number	 00000007h   
D_PTR  . . . . . . . . . . . . .	Text   	 DWORD PTR
Q_PTR  . . . . . . . . . . . . .	Text   	 QWORD PTR
R8Home . . . . . . . . . . . . .	Text   	 Q_PTR [ RSP + ( 3 * 8 ) ]
R9Home . . . . . . . . . . . . .	Text   	 Q_PTR [ RSP + ( 4 * 8 ) ]
RCXHome  . . . . . . . . . . . .	Text   	 Q_PTR [ RSP + ( 1 * 8 ) ]
RDXHome  . . . . . . . . . . . .	Text   	 Q_PTR [ RSP + ( 2 * 8 ) ]
W_PTR  . . . . . . . . . . . . .	Text   	 WORD PTR
XM_PTR . . . . . . . . . . . . .	Text   	 XMMWORD PTR
YM_PTR . . . . . . . . . . . . .	Text   	 YMMWORD PTR
ZM_PTR . . . . . . . . . . . . .	Text   	 ZMMWORD PTR
__CheckAlign . . . . . . . . . .	Number	 00000000h   
__UseBMI2  . . . . . . . . . . .	Number	 00000001h   
__UseQ . . . . . . . . . . . . .	Number	 00000001h   
__UseX . . . . . . . . . . . . .	Number	 00000000h   
__UseY . . . . . . . . . . . . .	Number	 00000000h   
__UseZ . . . . . . . . . . . . .	Number	 00000001h   
__VerifyRegs . . . . . . . . . .	Number	 00000001h   
_alignspace  . . . . . . . . . .	Number	 00000040h   
_allocspace  . . . . . . . . . .	Number	 00000280h   
_localspace  . . . . . . . . . .	Number	 000001C0h   
_shadowspace . . . . . . . . . .	Number	 00000040h   
add_uT64 . . . . . . . . . . . .	L 	 00000000 External
add_u_wc . . . . . . . . . . . .	L 	 00000000 External
add_u  . . . . . . . . . . . . .	L 	 00000000 External
and_u  . . . . . . . . . . . . .	L 	 00000000 External
compare_uT64 . . . . . . . . . .	L 	 00000000 External
compare_u  . . . . . . . . . . .	L 	 00000000 External
compile_time_options_INC . . . .	Text   	 1
copy_u . . . . . . . . . . . . .	L 	 00000000 External
l_Ptr  . . . . . . . . . . . . .	Text   	 [RBP] + div_u_Locals
lsb_u  . . . . . . . . . . . . .	L 	 00000000 External
m32BCST  . . . . . . . . . . . .	Text   	 DWORD BCST
m64BCST  . . . . . . . . . . . .	Text   	 QWORD BCST
msb_u  . . . . . . . . . . . . .	L 	 00000000 External
mskAll8  . . . . . . . . . . . .	DWord	 00000000 External
mskB0  . . . . . . . . . . . . .	DWord	 00000000 External
mskB1  . . . . . . . . . . . . .	DWord	 00000000 External
mskB2  . . . . . . . . . . . . .	DWord	 00000000 External
mskB3  . . . . . . . . . . . . .	DWord	 00000000 External
mskB4  . . . . . . . . . . . . .	DWord	 00000000 External
mskB5  . . . . . . . . . . . . .	DWord	 00000000 External
mskB6  . . . . . . . . . . . . .	DWord	 00000000 External
mskB7  . . . . . . . . . . . . .	DWord	 00000000 External
mult_uT64  . . . . . . . . . . .	L 	 00000000 External
mult_u . . . . . . . . . . . . .	L 	 00000000 External
nRegs  . . . . . . . . . . . . .	Number	 00000002h   
not_u  . . . . . . . . . . . . .	L 	 00000000 External
or_u . . . . . . . . . . . . . .	L 	 00000000 External
qOnes  . . . . . . . . . . . . .	QWord	 00000000 External
qZero  . . . . . . . . . . . . .	QWord	 00000000 External
reg_verify . . . . . . . . . . .	L 	 00000000 External
ret_GPFault  . . . . . . . . . .	DWord	 00000000 External
ret_neg_one  . . . . . . . . . .	DWord	 00000000 External
ret_one  . . . . . . . . . . . .	DWord	 00000000 External
ret_zero . . . . . . . . . . . .	DWord	 00000000 External
retcode_neg_one  . . . . . . . .	Number	 -00000001h   
retcode_one  . . . . . . . . . .	Number	 00000001h   
retcode_zero . . . . . . . . . .	Number	 00000000h   
set_uT64 . . . . . . . . . . . .	L 	 00000000 External
shl_u  . . . . . . . . . . . . .	L 	 00000000 External
shr_u  . . . . . . . . . . . . .	L 	 00000000 External
sub_uT64 . . . . . . . . . . . .	L 	 00000000 External
sub_u_wb . . . . . . . . . . . .	L 	 00000000 External
sub_u  . . . . . . . . . . . . .	L 	 00000000 External
ui512_externs_INC  . . . . . . .	Text   	 1
ui512_legalnotes_INC . . . . . .	Number	 00000001h   
ui512_macros_INC . . . . . . . .	Text   	 1
xor_u  . . . . . . . . . . . . .	L 	 00000000 External
zero_u . . . . . . . . . . . . .	L 	 00000000 External

	   0 Warnings
	   0 Errors
